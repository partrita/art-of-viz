---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-asp: 0.7
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

# 동물 보호소 입소: **`ggforce`**를 사용한 게이지 차트 만들기 {#sec-longbeach}

이 장에서는 **`ggforce`** 확장 패키지의 도움으로 **`ggplot2`**에 기본적으로 포함되지 않은 차트 유형인 게이지 차트를 만드는 방법을 알아봅니다.

이 장을 마치면 다음을 할 수 있게 됩니다:

* **`ggforce`** 패키지의 새로운 *geom* 함수를 사용하기 위해 플롯 요소의 크기를 프로그래밍 방식으로 계산하여 게이지 차트를 만듭니다.
* 다른 종횡비나 좌표계를 선택하면 차트의 모양이 어떻게 바뀔 수 있는지 확인합니다.
* 색상 선택이 색각 이상이 있는 사람들에게 접근 가능한지 분석합니다.

이 장에 필요한 패키지를 로드하는 것으로 시작합니다.

```{r}
#| label: longbeach-pkgs-req
#| warning: false
#| message: false
library(colorblindr)
library(dplyr)
library(ggforce)
library(ggplot2)
library(ggtext)
library(lubridate)
library(scales)
library(showtext)
library(sysfonts)
library(tidyr)
library(tidytuesdayR)
```


이 장에서는 이전 장에서 아직 사용하지 않은 몇 가지 새로운 패키지를 소개합니다:

* **`colorblindr`**: 색상 팔레트의 접근성과 차트의 색상 사용을 평가합니다.
* **`ggforce`**: **`ggplot2`**의 동작을 확장하고 추가 *geoms* 및 *stats*를 제공하는 패키지입니다.
* **`lubridate`**: 날짜 변수를 조작하고 생성하기 위한 패키지입니다. @sec-nobel 및 @sec-r-pkgs 에서 **`lubridate`**의 더 많은 예를 볼 수 있습니다.
* **`scales`**: **`ggplot2`**는 배경에서 **`scales`** 패키지를 사용하여 축 제한 및 레이블에 도움을 줍니다. 그러나 **`scales`**의 함수를 직접 사용하여 데이터, 레이블 및 색상을 변환할 수 있습니다.

\index{colorblindr} \index{ggforce} \index{lubridate} \index{scales}

## 데이터

Long Beach 동물 보호소 데이터 세트 [@longbeach_data]에는 2017년에서 2014년 사이에 보호소에 맡겨진 28,000마리 이상의 동물에 대한 입소 및 결과 정보가 포함되어 있습니다. 여기서 *맡겨진(surrendered)*이라는 용어는 보호소로 들어온 모든 동물을 의미하지만, 데이터 세트에는 소유자가 맡겼는지, 압수되었는지, 길 잃은 동물로 발견되었는지, 아니면 다른 수단을 통해 도착했는지에 대한 정보도 포함되어 있습니다.

동물 보호소 데이터 세트는 2025년 3월 TidyTuesday 데이터 세트로 사용되었으며 ([Lydia Gibson](https://github.com/lgibson7)이 큐레이팅한 후), 데이터는 **`animalshelter`** 패키지 [@animalshelter]를 통해서도 사용할 수 있습니다. **`tidytuesdayR`** R 패키지 [@tidytuesdayR]를 사용하여 데이터를 읽고 변수 정의를 살펴보는 것으로 시작하겠습니다: \index{tidytuesdayR!tt\_load}

```{r}
#| label: longbeach-load-data-show
#| eval: false
#| echo: true
tuesdata <- tt_load("2025-03-04")
longbeach <- tuesdata$longbeach
```

```{r}
#| label: longbeach-load-data-hide
#| output: false
#| echo: false
#| eval: true
longbeach <- readr::read_csv("data/longbeach.csv")
```

`longbeach` 데이터는 `r nrow(longbeach)`행과 `r ncol(longbeach)`열로 상당히 큽니다.

```{r}
#| label: longbeach-head-data
head(longbeach)
```

데이터 세트의 각 행은 서로 다른 입소와 관련이 있으며, `animal_id` 열에서 식별할 수 있듯이 일부 동물은 여러 번 나타납니다. 이름, 동물의 종류(예: 고양이 또는 개), 색상, 성별 및 생년월일과 같은 각 개별 동물에 대한 추가 정보가 제공됩니다. 이러한 열 중 상당수는 주로 길 잃은 동물로 도착한 동물에 대한 정보 부족으로 인해 누락된 값이 과도하게 많습니다. 추가 열은 날짜, 유형 및 하위 유형(예: 소유자 포기 또는 길 잃음)을 포함한 입소에 대한 정보와 입소에 대한 이유를 제공하는 자유 텍스트 응답을 제공합니다. 좌표 날짜 및 관할 구역을 포함하여 포획 또는 입소의 지리적 위치에 대한 더 자세한 정보가 제공됩니다. 마지막으로, 결과가 발생한 시기, 유형 및 하위 유형(예: 입양 또는 사망)을 포함하여 각 동물의 결과에 대한 데이터도 제공됩니다. 다양한 결과에 대한 일부 이진 변수도 미리 계산됩니다.

## 탐색 작업

동물과 입소 및 결과에 대해 기록된 다양한 측면을 고려할 때 더 조사할 수 있는 변수가 많이 있습니다. 이 데이터의 어떤 측면을 시각화하는 것이 흥미로울까요?

### 데이터 탐색

이 책의 다른 장과 마찬가지로 기본 R의 몇 가지 기본 탐색 플롯으로 시작하겠습니다. 예를 들어 @fig-longbeach-barplot 의 `barplot()` 함수를 사용하여 각 `animal_type`의 변수 분포를 볼 수 있습니다. \index{graphics!barplot}

```{r, echo=-1}
#| label: fig-longbeach-barplot
#| fig-cap: "동물 유형별 총 입소 동물 수 막대 차트."
#| fig-alt: "동물 유형별 총 입소 동물 수 막대 차트. 고양이가 가장 많습니다."
par(mar = c(2.1, 6.1, 1.1, 1.1), cex.axis = 0.5, cex.names = 0.5)
barplot(
  table(longbeach$animal_type),
  las = 1,
  horiz = TRUE
)
```

고양이와 관련된 관찰이 많으며 개가 꽤 근접하게 2위를 차지했습니다. 이것은 이런 종류의 동물을 반려동물로 키우는 것이 얼마나 흔한지를 나타낼 가능성이 큽니다. 또한 @fig-longbeach-scatterplot 에 표시된 대로 입소 횟수가 시간이 지남에 따라 어떻게 변했는지에 관심이 있을 수 있습니다.

```{r, echo=-1}
#| label: fig-longbeach-scatterplot
#| fig-cap: "일일 입소 동물 수를 보여주는 선형 차트로, 계절적 피크와 2020-2021년 동안 낮은 수치를 보여줍니다."
#| fig-alt: "일일 입소 동물 수를 보여주는 선형 차트로, 계절적 피크와 2020-2021년 동안 낮은 수치를 보여줍니다."
par(mar = c(3.1, 2.1, 2.1, 2.1), cex = 0.5)
plot(
  x = table(longbeach$intake_date),
  xlab = "", ylab = "",
  main = "Number of animals surrendered per day"
)
```

입소 횟수에 약간의 계절적 차이가 있으며 2020년과 2021년 동안 약간 감소한 것으로 보입니다. 이는 아마도 COVID-19 팬데믹이 포획할 수 있는 동물 수에 영향을 미쳤기 때문일 것입니다.

@fig-longbeach-heatmap 의 기본 R에서 `heatmap()` 함수를 사용하여 다양한 동물 유형에 대한 입소 횟수가 시간이 지남에 따라 어떻게 변했는지 살펴보는 것이 더 흥미로울 수 있습니다. \index{stats!heatmap}

```{r, echo=-1}
#| label: fig-longbeach-heatmap
#| fig-cap: "매년 각 유형의 입소 동물 수 히트맵. 2020년과 2021년에는 모든 유형의 동물이 더 적게 입소했습니다."
#| fig-alt: "매년 각 유형의 입소 동물 수 히트맵. 2020년과 2021년에는 모든 유형의 동물이 더 적게 입소했습니다."
par(mar = c(3.1, 0, 2.1, 0))
heatmap(
  table(
    longbeach$animal_type,
    year(longbeach$intake_date)
  ),
  # prevent re-ordering
  Rowv = NA,
  Colv = NA,
  # make labels smaller so they fit on the page
  margins = c(3, 6),
  cexRow = 0.5,
  cexCol = 0.5
)
```

@fig-longbeach-heatmap 에서는 일부 동물 유형의 수가 매우 적으므로 데이터를 연간 값으로 집계하기 위해 **`lubridate`**의 `year()` 함수를 사용하여 날짜 변수에서 연도를 추출했습니다.

이 데이터를 더 의미 있고 미적인 방식으로 시각적으로 표현하는 방법에 대해 생각해 봅시다. 모든 연도의 데이터를 포함하면 값의 추세를 고려할 수 있지만 때로는 몇 가지 스냅샷만 보는 것이 더 효과적일 수 있습니다. 예를 들어, 여기서 할 것처럼 2017년과 2023년만 고려함으로써 독자는 점진적인 추세에 대한 시각적 효과가 덜할 수 있는 시각적 효과보다는 *와, 상황이 얼마나 변했는지 봐!*라는 메시지를 받을 수 있습니다. 또한 이를 통해 장기적인 추세를 설명하려고 시도하는 동시에 팬데믹의 영향을 정량화하려고 하기보다는 팬데믹 전후의 수치를 비교할 수 있습니다.

다시 **`lubridate`**의 `year()`를 사용하여 추출된 연도를 새 열로 저장하고 **`dplyr`**\index{dplyr}의 `filter()`\index{dplyr!filter} 함수를 사용하여 `longbeach` 데이터 세트를 필터링하여 2017년과 2023년의 행만 고려할 수 있습니다. 일부 동물 유형은 연간 데이터로 집계하더라도 숫자가 매우 작으므로 `if_else()`를 사용하여 이미 존재하는 `"other"` 범주에 더 많은 동물 유형을 포함할 것입니다. 그런 다음 **`dplyr`**의 `count()`를 사용하여 관심 있는 각 연도에 각 동물 유형이 얼마나 많이 입소했는지 계산합니다.

```{r}
#| label: filter-longbeach
# subset data for years and combine aninmal types
intake_data <- longbeach |>
  mutate(
    year = year(intake_date),
    animal_type = if_else(
      animal_type %in% c(
        "dog", "cat", "bird",
        "wild", "reptile"
      ),
      animal_type,
      "other"
    )
  ) |>
  filter(
    year %in% c(2017, 2023)
  ) |>
  count(year, animal_type)
head(intake_data)
```

이제 데이터에는 2017년과 2023년(`year`) 각각의 각 동물 유형(`animal_type`)의 수(`n`)만 표시됩니다. 이 데이터를 어떻게 시각화할 수 있을까요? 떠오르는 몇 가지 분명한 옵션이 있습니다. 간단한 그룹 막대 차트, 슬로프 차트 또는 (자주 인기가 없는) 파이 차트입니다. 데이터 시각화의 선택은 우리가 보여주고자 하는 데이터의 측면에 따라 달라집니다. 2017년과 2023년을 비교하고 싶습니까? 다른 동물 유형의 상대적 수를 보고 싶습니까? 아니면 데이터의 값 범위를 보여주고 싶습니까? 이 데이터에서 가장 흥미로운 예는 아마도 2017년과 2023년을 비교하는 것일 것입니다. 슬로프 차트가 이 데이터에 잘 작동할 가능성이 높지만 게이지 차트로 조금 더 실험적으로 진행해 보겠습니다.

글을 쓰는 시점에는 **`ggplot2`**에 게이지 차트를 만드는 내장 함수가 없습니다. 게이지 차트\index{gauge chart}를 들어 본 적이 없다면 @fig-longbeach-sketch 의 초기 스케치가 우리가 목표로 하는 것에 대한 아이디어를 줄 수 있습니다.

### 탐색적 스케치

게이지 차트는 반원 위로 구부러진 누적 막대 차트라고 생각할 수 있습니다. 여기서는 하나의 누적 막대 차트 대신 두 개의 누적 막대 차트가 있습니다.

![단일 동물 유형에 대한 데이터를 시각화하기 위한 아이디어의 초기 스케치.](images/sketch-longbeach.png){#fig-longbeach-sketch fig-align="center" fig-alt="단일 동물 유형에 대한 데이터를 시각화하기 위한 아이디어의 초기 스케치."}

게이지 차트에는 종종 값을 더 강조하기 위해 다이얼(또는 바늘)이 포함되지만 여러 개의 게이지가 있는 경우 조금 복잡해집니다. 그러니 지금은 그냥 둡시다. \index{gauge chart}

## 플롯 준비하기

게이지 차트는 **`ggplot2`**의 내장 기능이 아니므로 플로팅을 시작하기 전에 수동 준비를 조금 해야 합니다.

### 데이터 랭글링

**`ggplot2`**에서 기본적으로 게이지 차트를 만들기 위해 `geom_col()` 및 `coord_polar()`를 사용할 *수* 있습니다. 그러나 **`ggplot2`**에서 극좌표를 사용하면 주석과 같은 요소를 원하는 위치에 추가하기 어려운 경우가 많습니다. 그러니 약간 다른 방식으로 게이지 차트를 만들어 봅시다! \index{ggplot2!geom\_col} \index{ggplot2!coord\_polar}

게이지 차트는 일반적으로 목표나 제한에 대한 진행 상황을 표시하는 데 사용됩니다. 예를 들어 백분율로 제공된 데이터를 고려할 때 100%가 일반적인 상한입니다. 우리 데이터의 경우 보호소의 최대 수용 인원을 알고 있다면 적절한 선택이 될 것입니다. 그러나 그 정보가 없으므로 *자연적인* 제한이 없습니다.

따라서 다음과 같은 합리적인 것을 결정해야 합니다:

* 모든 연도에 걸쳐 입소한 모든 동물의 최대 수
* 선택한 연도에 걸쳐 입소한 모든 동물의 최대 수
* 모든 연도에 걸쳐 입소한 단일 유형 동물의 최대 수
* 선택한 연도에 걸쳐 입소한 단일 유형 동물의 최대 수

어떤 의미에서 선택은 상당히 임의적이며 강조하려는 내용에 따라 다릅니다. 여기서는 선택한 연도에 걸쳐 입소한 단일 유형 동물의 최대 수를 사용합니다. `ceiling()`을 사용하여 가장 가까운 500으로 반올림하여 *더 좋은* 상한을 제공합니다. \index{base!ceiling}

```{r}
#| label: wrangle-longbeach-0
max_intake <- max(intake_data$n)
upper_limit <- ceiling(max_intake / 500) * 500
c(max_intake, upper_limit)
```

::: {#tip-longbeach-rounding .callout-tip}

## R에서 숫자 반올림

R에서 `round()` 함수는 숫자를 반올림하는 데 사용할 수 있으며 `digits` 인수는 정밀도 수준을 지정합니다. 음수를 제공하면 10, 100, 1000 등으로 반올림할 수 있습니다. \index{base!round}

```{r}
#| label: longbeach-round-example
round(1234, digits = -1)
round(1234, digits = -2)
round(1234, digits = -3)
```

그러나 10의 거듭제곱이 아닌 숫자로 반올림하려면 해당 숫자로 나누고 반올림한 다음 다시 숫자를 곱할 수 있습니다. `round()`를 `floor()` 또는 `ceiling()`으로 바꾸면 각각 내림 또는 올림을 할 수 있습니다.

:::

`n`을 선택한 상한으로 나누어 각 범주에 대해 해당 제한(`value`)에 대해 얼마나 진전이 있었는지 확인합시다. 나중에 플롯하기 쉽게 하기 위해 각 범주가 해당 제한(`no_value`)에서 얼마나 떨어져 있는지도 계산합니다. `n` 열은 더 이상 필요하지 않으므로 **`dplyr`**의 `select()`를 사용하여 삭제합니다. \index{dplyr!select} \index{dplyr!mutate}

그런 다음 **`tidyr`**의 `pivot_longer()` 및 `pivot_wider()` 함수를 사용하여 데이터를 긴 형식으로 피벗했다가 다시 되돌립니다. 그 결과 각 동물 유형에 대해 데이터에 두 개의 행이 생성됩니다. (i) 2017년과 2023년 제한에 대한 백분율에 대한 행 하나, (ii) 2017년과 2023년 제한으로부터의 백분율에 대한 행 하나입니다. \index{tidyr!pivot\_wider} \index{tidyr!pivot\_longer}

```{r}
#| label: wrangle-longbeach-1
intake_YN <- intake_data |>
  mutate(
    value = n / upper_limit,
    no_value = 1 - value
  ) |>
  select(-n) |>
  pivot_longer(
    cols = c(value, no_value),
    names_to = "YN",
    values_to = "perc"
  ) |>
  pivot_wider(
    names_from = "year",
    values_from = "perc"
  ) |>
  mutate(YN = factor(YN))
```

누적 막대 차트(즉, 펼쳐진 게이지 차트)를 만드는 것을 생각해 보면 각 막대의 끝점(각 막대의 최대 y축 값)을 알아야 합니다. 이것은 각 그룹의 백분율이 아니라 각 그룹과 그 아래에 쌓인 그룹의 누적 백분율입니다. `cumsum()` 함수를 사용하여 각 연도 및 동물 유형에 걸쳐 누적 합계를 계산합니다: \index{cumsum}

```{r}
#| label: wrangle-longbeach-2
plot_data <- intake_YN |>
  group_by(animal_type) |>
  mutate(
    ymax_2017 = cumsum(`2017`),
    ymax_2023 = cumsum(`2023`)
  )
head(plot_data)
```

`no_value` 행에 대한 `ymax_*` 값은 항상 `1`이라는 것을 알 수 있습니다. 이는 `no_value`가 마지막 막대이므로 해당 막대를 완료할 때쯤이면 항상 데이터의 100%를 플로팅했을 것이기 때문입니다. 데이터는 현재 여전히 `animal_type`별로 그룹화되어 있다는 점에 유의하십시오. 이것은 나중에 중요할 것입니다!

### **`ggforce`** 확장 패키지

**`ggforce`**\index{ggforce} 확장 패키지 [@ggforce]는 **`ggplot2`**의 동작을 확장하는 많은 유용한 함수를 포함하고 있으며, 그중 많은 함수가 탐색적 데이터 시각화를 목표로 합니다. 이 장에서는 많은 함수를 다루지 않고 대신 게이지 차트를 만드는 데 사용하는 방법에 초점을 맞출 것입니다. **`ggforce`**는 CRAN에서 사용할 수 있으며 일반적인 `install.packages("ggforce")` 명령으로 설치할 수 있습니다.

### **`ggforce`**를 사용한 게이지 차트

게이지 차트를 만드는 목적을 위해 관심 있는 함수는 `geom_arc_bar()` \index{ggforce!geom\_arc\_bar}입니다. `geom_arc_bar()` 함수를 사용하면 **`ggplot2`**에서 호를 그릴 수 있습니다. 이 함수를 사용하여 도넛 차트나 선버스트 플롯과 같은 시각화를 만들 수도 있습니다. 이중 게이지 차트를 만들기 위해 `geom_arc_bar()`를 두 번 호출합니다 - 하나는 2017년 호용이고 다른 하나는 2023년 호용입니다. `geom_arc_bar()`를 사용할 때 필요한 몇 가지 필수 미학이 있습니다:

* `x0`: 게이지 차트가 놓인 원의 중심의 x 좌표입니다. 우리에게 이것은 상수 값이 될 것이므로 아무 숫자나 선택할 수 있습니다 - `0`이 분명한 선택인 것 같습니다.
* `y0`: 게이지 차트가 놓인 원의 중심의 y 좌표입니다. 우리에게 이것은 상수 값이 될 것이므로 아무 숫자나 선택할 수 있습니다 - 다시 `0`이 분명한 선택인 것 같습니다.
* `r0`: 호의 내부 반지름(`x0` 및 `y0`에서).
* ``r``: 호의 외부 반지름(`x0` 및 `y0`에서). `r0`와 ``r``의 차이는 게이지 차트의 두께를 결정합니다. 우리가 그릴 두 호 각각에 대해 이것들은 일정할 것입니다. 외부 호(2023)의 경우 `r0 = 0.7` 및 ``r`` = 1로 설정할 수 있고 내부 호(2017)의 경우 `r0 = 0.2` 및 ``r`` = 0.5로 설정할 수 있습니다. 두 호의 반지름 차이는 0.3이므로 두께가 동일하다는 점에 유의하십시오.
* `start`: 호의 각 세그먼트의 시작 각도.
* `end`: 호의 각 세그먼트의 끝 각도.

우리가 해야 할 데이터 랭글링의 마지막 부분은 `start` 및 `end` 값을 계산하는 것입니다.

### 미학 계산

끝 값은 쉽습니다. 이미 가지고 있는 `ymax_2017` 및 `ymax_2023` 열입니다. 동등한 `ymin_2017` 및 `ymin_2023` 값을 계산해야 합니다. 각 누적 막대 차트의 최소값은 무엇일까요?

잠시 게이지 차트 대신 누적 막대 차트를 다시 생각해 봅시다(시각화하기가 조금 더 쉽기 때문입니다). 스택 맨 아래에 있는 첫 번째 막대의 최소값은 항상 0이 될 것입니다. 맨 아래에 있기 때문입니다. 나머지 누적 막대의 경우 최소값은 그 아래에 쌓인 막대의 최대값과 같을 것입니다. 이는 우리가 필요한 모든 값을 이미 계산하여 `plot_data`에 저장했음을 의미합니다. 이제 약간 재정렬하기만 하면 됩니다.

::: {#tip-longbeach-ymin .callout-tip}

## 할 수 있다고 해서 해야 하는 것은 아닙니다

기본 R에는 코드 줄 수가 적고 읽기 쉬운 더 좋은 방법이 거의 확실히 있습니다. 다음 코드 블록은 우리가 *해야 하는지* 고려하지 않고 파이프형 워크플로에서 이 작업을 *할 수 있는지* 확인하는 실험으로 간주하십시오!

:::

2017년 데이터부터 시작하겠습니다. 먼저 `rep(0, n_types)`를 사용하여 첫 번째 누적 막대의 최소값에 대해 `0` 값을 생성합니다. 2017년에는 각 동물 유형에 대해 하나의 `0`이 필요하기 때문입니다. 그런 다음 마지막 항목을 제외한 `plot_data`에서 `ymax_2017` 값을 가져오려고 합니다. 따라서 `slice_head()`를 사용하여 이 행의 하위 집합을 가져옵니다(각 동물 유형에서 마지막 항목이 누락됨). `plot_data`는 여전히 `animal_type`별로 그룹화되어 있다는 것을 기억하십시오. 그런 다음 이 `ymax_2017`을 생성한 `0`에 붙이고 `mutate()`를 사용하여 `ymin_2017`이라는 새 열에 전달합니다. 2023년 호에 대한 코드는 유사합니다. \index{dplyr!mutate} \index{dplyr!slice\_head} \index{dplyr!pull}

```{r}
#| label: longbeach-gauge-data-1
n_types <- length(
  unique(plot_data$animal_type)
)
ymin_data <- plot_data |>
  ungroup() |>
  # start values for 2017 arc
  mutate(
    ymin_2017 = c(rbind(
      rep(0, n_types),
      (slice_head(plot_data, n = -1) |>
        pull(ymax_2017))
    ))
  ) |>
  # repeat for 2023
  mutate(
    ymin_2023 = c(rbind(
      rep(0, n_types),
      (slice_head(plot_data, n = -1) |>
        pull(ymax_2023))
    ))
  )
```

우리의 모든 변수는 현재 0과 1 사이의 척도로 조정되어 있습니다(제한에 대한 백분율과 관련이 있기 때문입니다). 하지만 이것을 호로 그리려면 극좌표로 변환해야 합니다. 호를 $-\pi/2$(0 대신)에서 시작하고 $\pi/2$(1 대신)에서 끝내려고 합니다. **`scales`** 패키지 [@scales]의 `rescale()` 함수를 사용하여 `from`과 `to`로 스케일링할 범위를 정의할 수 있습니다. \index{scales!rescale}

소문자 `"y"`로 시작하는 `ymin_data`의 모든 열, 즉 모든 `ymax_*` 및 `ymin_*` 열에 이것을 적용하고 싶으므로 `starts_with()` 열 선택기 함수와 함께 **`dplyr`**의 `mutate()` 및 `across()`를 사용합니다. **`dplyr`**가 `YN` 열도 다시 스케일링하는 것을 방지하기 위해 `ignore.case = FALSE`를 설정해야 합니다. \index{dplyr!starts\_with} \index{dplyr!across} \index{dplyr!mutate}

::: {#tip-longbeach-mutate .callout-tip}

## `mutate()`의 이전 버전

**`dplyr`**의 이전 버전에서는 `mutate()` 및 `across()` 대신 `mutate_at()` 함수가 사용되었습니다. `mutate_at()` 함수는 이제 대체되었습니다.

:::

```{r}
#| label: longbeach-gauge-data-2
gauge_data <- ymin_data |>
  mutate(
    across(
      starts_with("y", ignore.case = FALSE),
      ~ rescale(.,
        to = pi * c(-0.5, 0.5),
        from = 0:1
      )
    )
  )
head(gauge_data)
```

### 첫 번째 플롯

이제 데이터 랭글링이 끝났고(드디어!) 첫 번째 플롯을 만들 준비가 되었습니다. 항상 그렇듯이 `ggplot()` 함수로 시작하고 호를 그리는 데 사용할 `gauge_data`를 전달합니다. 각 호의 미학은 다양하므로 전역적으로 전달하는 것을 보류합니다. \index{ggplot2!ggplot} \index{ggplot2!aes}

그런 다음 `geom_arc_bar()`를 두 번 사용하여 두 개의 호를 추가합니다. 위에서 설명한 대로 `x0`, `y0`, `r0`, `r` 상수를 설정합니다. 미학에 대해 상수 값을 선택했더라도 *필수* 미학이므로 `aes()` 함수 안에 있어야 합니다. 그런 다음 `ymin_*` 및 `ymax_*` 열을 `start` 및 `end` 미학으로 전달하고 `YN` 열을 기반으로 `fill` 색상을 설정합니다. \index{ggforce!geom\_arc\_bar}

또한 `facet_wrap()`을 사용하여 각 동물 유형에 대한 호 쌍을 별도의 패싯에 그리고 `nrow = 2`를 사용하여 6개국에 대한 멋진 직사각형 3x2 그리드 패싯을 제공하도록 선택합니다. \index{ggplot2!facet\_wrap} 

```{r}
#| label: fig-longbeach-basic-plot-1
#| fig-cap: "Initial plot created using `geom_arc_bar()` from `ggforce`, faceted by different animal types."
#| fig-alt: ""
#| warning: false
basic_plot <- ggplot(data = gauge_data) +
  # Outer 2023 arc
  geom_arc_bar(
    mapping = aes(
      x0 = 0, y0 = 0,
      r0 = 0.7, r = 1,
      start = ymin_2023, end = ymax_2023,
      fill = YN
    )
  ) +
  # Inner 2017 arc
  geom_arc_bar(
    mapping = aes(
      x0 = 0, y0 = 0,
      r0 = 0.2, r = 0.5,
      start = ymin_2017, end = ymax_2017,
      fill = YN
    )
  ) +
  facet_wrap(~animal_type, nrow = 2)
basic_plot
```

## 고급 스타일링

이제 이중 게이지 차트가 생겼습니다. 하지만 훨씬 더 보기 좋게(그리고 더 유익하게) 만들 수 있습니다!

### 색상

색상에 대한 몇 가지 변수를 정의하는 것으로 시작하겠습니다. 여기서 우리는 목표에 대한 백분율, 즉 입소한 동물 수를 보여주는 세그먼트에 사용할 분홍색 `highlight_col`을 정의합니다. 이것은 우리가 전달하려는 요점이기 때문에 밝고 눈길을 끄는 색상이어야 합니다. `second_col`은 목표에 대해 남은 백분율을 보여주는 데 사용되므로 배경과 조금 더 유사한 색상을 선택할 수 있습니다. 배경(`bg_col`)은 밝은 회색, `second_col`은 중간 회색, 텍스트(`text_col`)는 검은색이 됩니다. \index{color}

```{r}
#| label: longbeach-colors
highlight_col <- "#990C58"
second_col <- "#949398"
bg_col <- "#DEDEDE"
text_col <- "black"
```

게이지 차트에 새 색상을 추가하기 전에 세그먼트 주변의 검은색 윤곽선을 제거해 보겠습니다. 플롯에 아무것도 추가하지 않는 꽤 두꺼운 선입니다. 우리가 선택한 새 색상으로 세그먼트 사이에 충분한 대비가 있을 것입니다. 미적 매핑 외부에서 `color = NA`를 설정하여 호에서 윤곽선을 제거할 수 있습니다. \index{ggforce!geom\_arc\_bar} \index{ggplot2!ggplot} \index{ggplot2!facet\_wrap} \index{ggplot2!aes}

```{r}
#| label: fig-longbeach-basic-plot-2
#| fig-cap: "A second version of the initial plot created using `geom_arc_bar()` from `ggforce`, faceted by different animal types, with the outline color removed."
#| fig-alt: "A second version of the initial plot created using `geom_arc_bar()` from `ggforce`, faceted by different animal types, with the outline color removed."
#| source-line-numbers: "9,18"
basic_plot <- ggplot(data = gauge_data) +
  geom_arc_bar(
    mapping = aes(
      x0 = 0, y0 = 0,
      r0 = 0.7, r = 1,
      start = ymin_2023, end = ymax_2023,
      fill = YN
    ),
    color = NA
  ) +
  geom_arc_bar(
    mapping = aes(
      x0 = 0, y0 = 0,
      r0 = 0.2, r = 0.5,
      start = ymin_2017, end = ymax_2017,
      fill = YN
    ),
    color = NA
  ) +
  facet_wrap(~animal_type, nrow = 2)
```

이제 **`ggplot2`**의 `scale_fill_manual()`을 사용하여 색상을 적용할 수 있습니다. \index{ggplot2!scale\_fill\_manual}

```{r}
#| label: fig-longbeach-color-plot
#| fig-cap: "Edited version of the previous plot with colors changed from defaults to gray and dark pink."
#| fig-alt: "Edited version of the previous plot with colors changed from defaults to gray and dark pink."
color_plot <- basic_plot +
  scale_fill_manual(
    breaks = c("value", "no_value"),
    values = c(highlight_col, second_col)
  )
color_plot
```

시각화를 위한 색상을 선택할 때 그룹을 구분하거나 정보를 전달하기 위해 색상과 범례에 너무 많이 의존하지 않는 것이 중요합니다. 색각 이상(색맹이라고도 함)은 다양한 형태로 나타나며 유형에 따라 사람들이 색상을 인식하는 방식이 다릅니다. 차트가 색각 이상이 있는 사람들에게 접근 가능한지 확인하는 한 가지 방법은 회색조(흑백)로 보고 색상 없이 이해할 수 있는지 확인하는 것입니다. 그럴 수 없다면 다른 색상을 선택하거나 모양과 패턴을 사용하여 그룹을 구별하는 것을 고려하십시오. 범례를 피할 수 없을 때 데이터를 직접 레이블링하고 범례의 순서가 데이터의 순서와 일치하는지 확인하면 도움이 될 수 있습니다 [@GAcharts]. \index{accessibility} \index{legend} \index{color}

R에는 색상 팔레트의 접근성을 조사하는 데 사용할 수 있는 여러 패키지가 있습니다. 그중 하나는 **`colorblindr`** [@colorblindr]입니다. **`colorblindr`** 패키지를 사용하면 색맹이 있는 사람에게 차트가 어떻게 보일지 시뮬레이션할 수 있습니다. 이 패키지에는 관련 **`ggplot2`** 함수가 있는 색맹 친화적인 질적 팔레트도 포함되어 있습니다. 글을 쓰는 시점에서 **`colorblindr`**은 CRAN에서 사용할 수 없지만 @sec-bees 에 설명된 방법을 사용하여 GitHub에서 설치할 수 있습니다. \index{colorblindr!cvd\_grid}

```{r, echo=2}
#| label: fig-longbeach-cvd
#| fig-cap: "A 2x2 grid of charts showing simulations of how the current chart might appear to people with each of four different types of color vision deficiency."
#| fig-alt: "A 2x2 grid of charts showing simulations of how the current chart might appear to people with each of four different types of color vision deficiency."
#| fig-dpi: 250
theme_set(theme_gray(base_size = 3))
cvd_grid(color_plot)
theme_set(theme_gray(base_size = 11))
```

**`ggplot2`**의 기본 색상 팔레트는 회색조로 볼 때 구분이 되지 않으므로 차트에 어떤 색상을 사용할지 생각하는 것이 중요합니다.

### 텍스트 및 글꼴

이전 장에서 보았듯이 **`sysfonts`**\index{sysfonts} 및 **`showtext`**\index{showtext} 패키지를 사용하여 Google 글꼴을 로드할 수 있습니다. 여기서는 제목과 본문 모두에 `"Ubuntu"` 서체를 사용하여 깔끔하고 미니멀하게 유지합니다. \index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: longbeach-fonts
font_add_google(name = "Ubuntu")
showtext_auto()
showtext_opts(dpi = 300)
body_font <- "Ubuntu"
```

제목과 부제목에 대한 텍스트를 정의해 보겠습니다. 여기서 제목은 차트의 핵심 메시지를 정의하여 독자가 그래픽을 훑어보더라도 요점을 이해할 수 있도록 합니다. 부제목은 플롯을 해석하는 방법에 대한 간단한 설명을 제공하고 독자가 가져가기를 원하는 주요 결론을 반복합니다. `caption` 변수는 이 시각화에 대한 데이터 소스와 차트 작성자를 식별합니다.

```{r}
#| label: longbeach-text
title <- "The number of animals surrendered is lower in 2023 compared to 2017"
subtitle <- "The inner pink bar represents the number of animals surrendered in 2017, whilst the outer pink bar represents the number in 2023. A decrease is seen across all types of animals."
caption <- "Data: City of Long Beach Animal Care Services | Graphic: N. Rennie"
```

축 레이블은 `geom_arc_bar()` 플롯에 큰 의미가 없으므로 나중에 `theme`\index{ggplot2!theme} 함수를 사용할 때 제거할 것입니다. 대신 게이지 끝에 `geom_text()`\index{ggplot2!geom\_text}를 사용하여 자체 레이블을 추가할 수 있습니다. 더 쉽게 하기 위해 텍스트 레이블을 추가하기 위한 작은 `data.frame`을 구성할 수 있습니다. 여기에는 텍스트가 위치해야 하는 `x` 및 `y` 좌표(아직 축 레이블을 삭제하지 않았으므로 이미 있는 그래프에서 읽을 수 있음)와 나타날 `label`이 포함됩니다.

```{r}
#| label: longbeach-text-df
text_df <- data.frame(
  x = c(0.35, 0.85),
  y = c(-0.1, -0.1),
  label = c(2017, 2023)
)
```

그런 다음 방금 만든 텍스트 `data.frame`을 사용하여 `data` 인수를 지정해야 한다는 점에 유의하면서 `geom_text()`\index{ggplot2!geom\_text}가 있는 레이어를 추가하여 기존 플롯에 이 텍스트를 추가할 수 있습니다. 또한 `geom_text()` 함수 내에서 서체와 크기를 직접 지정해야 하며 **`ggplot2`**의 `labs()` 함수\index{ggplot2!labs}를 사용하여 이전에 만든 제목과 부제목 텍스트를 추가할 수 있습니다.

```{r}
#| label: fig-longbeach-text
#| fig-cap: "Previous plot with additional labels indicating the year on each gauge chart, as well as an added title and subtitle."
#| fig-alt: "Previous plot with additional labels indicating the year on each gauge chart, as well as an added title and subtitle."
text_plot <- color_plot +
  geom_text(
    data = text_df,
    mapping = aes(x = x, y = y, label = label),
    family = body_font,
    size = 3
  ) +
  labs(
    title = title,
    subtitle = subtitle,
    caption = caption
  )
text_plot
```

### 테마 조정

회색 배경, 그리드 선 및 축 레이블과 같은 모든 테마 요소를 제거하는 것으로 시작하겠습니다. 가장 쉬운 방법은 `theme_void()`\index{ggplot2!theme\_void}를 사용하는 것입니다. `theme_void()`의 `base_family` 인수를 사용하여 남아 있는 모든 비 geom 텍스트 요소에 기본적으로 사용될 서체를 설정할 수 있습니다.

현재 게이지 플롯이 약간 찌그러져 보이고 반원형이 아니라는 것을 눈치챘을 것입니다. 플롯 패널에 1:1 종횡비를 강제하는 `coord_fixed()` \index{ggplot2!coord\_fixed}를 추가하여 이 문제를 해결할 수 있습니다.

```{r}
#| label: fig-longbeach-style-1
#| fig-cap: "Edited version of previous plot with fixed coordinate system to prevent squashing, and all theme elements removed."
#| fig-alt: "Edited version of previous plot with fixed coordinate system to prevent squashing, and all theme elements removed"
theme_plot <- text_plot +
  coord_fixed() +
  theme_void(base_size = 8.5, base_family = body_font)
theme_plot
```

보기가 더 좋아졌지만 여전히 훌륭하지는 않습니다. 스타일링으로 무엇을 더 개선해야 할까요?

* 제목 텍스트가 눈에 띄지 않고 부제목, 패싯 텍스트와 너무 쉽게 섞입니다. 아마도 **굵은** 글꼴이 도움이 될까요?
* 부제목 텍스트가 페이지에 맞지 않지만 익숙해졌을 **`ggtext`**의 `element_textbox_simple()` 함수를 사용하여 해결할 수 있습니다.
* 특정 종횡비를 강제로 사용하기 위해 `coord_fixed()`를 사용하고 있기 때문에 이제 꽤 이상한 간격 문제가 발생했습니다. 플롯의 상단과 하단에 큰 흰색 간격이 있고 연도 레이블이 하단에서 약간 잘렸습니다.
* 범례가 많은 공간을 차지하고 정보가 별로 없습니다.

\index{ggplot2!coord\_fixed} \index{ggtext!element\_textbox\_simple}

`theme()` 요소를 편집하여 처음 두 가지 문제를 해결해 보겠습니다.

* 부제목에 `element_textbox_simple()`을 사용하여 텍스트를 왼쪽 정렬합니다.
* 제목과 패싯 `strip.text`에 대해 `face = "bold"`를 설정하고 `rel()` 함수를 사용하여 글꼴 크기를 늘립니다.
* 이전 시각화에서 했던 것처럼 배경색을 `bg_col`로 설정하고 `plot.margin` 인수를 설정하여 가장자리 주위에 패딩을 추가합니다.

\index{ggplot2!rel}

```{r}
#| label: fig-longbeach-style-2
#| fig-cap: "Further styling of gauge chart to change background color, prevent overlapping in the subtitle text, and increase the size of the title."
#| fig-alt: "Further styling of gauge chart to change background color, prevent overlapping in the subtitle text, and increase the size of the title."
styled_plot <- theme_plot +
  theme(
    plot.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    strip.text = element_text(
      face = "bold", size = rel(1.2),
      margin = margin(b = 5)
    ),
    plot.title = element_text(
      margin = margin(b = 10),
      hjust = 0,
      face = "bold",
      size = rel(1.2)
    ),
    plot.subtitle = element_textbox_simple(
      margin = margin(b = 10),
      hjust = 0,
      halign = 0
    ),
    plot.caption = element_text(
      margin = margin(t = 10),
      hjust = 0
    ),
    plot.margin = margin(5, 5, 5, 5)
  )
styled_plot
```

거의 다 왔지만 연도 레이블 텍스트가 약간 찌그러져 있습니다. 문제의 일부는 범례가 차지하는 공간의 양입니다. 오른쪽 상단과 하단 모서리에 너무 많은 빈 공간을 남겨두고 더 필요한 다른 곳의 공간을 빼앗아갑니다. 이것은 차트를 개발할 때 흔히 발생하는 문제를 강조합니다. 시각화의 크기는 얼마나 커야 할까요? 이미지의 올바른 크기를 선택하는 것은 플롯에서 고정된 종횡비를 사용할 때(예: `coord_fixed()` 또는 공간 좌표를 사용할 때 - @sec-time-zones 에서 볼 수 있음) 특히 중요합니다. 잘못 선택하면 플롯이 잘리거나 여분의 공백이 생길 수 있기 때문입니다. \index{ggplot2!coord\_fixed}

::: {#tip-longbeach-aspect .callout-tip}

## 종횡비 선택

너비와 높이에 대해 생각하는 것보다 종횡비와 너비(또는 높이)에 대해 생각하는 것이 더 도움이 될 때가 많습니다. 이렇게 하면 이미지 크기를 늘리는 과정이 조금 더 쉬워지는 경우가 많습니다. \index{aspect ratio}

일반적으로 사용되는 종횡비가 있습니다(예: 4x6, 5x7 또는 1x1). 일반적으로 사용되는 종횡비를 선택하면 특히 웹 사이트나 슬라이드에서 여러 플롯을 정렬하기가 더 쉬울 수 있습니다. 출판물의 일부로 플롯을 만드는 경우 일부 학술지나 잡지에는 특정 종횡비 요구 사항이 있을 수 있습니다. 그렇지 않으면 탐색적 스케치를 사용하여 적절한 종횡비를 결정하십시오.

:::

::: {#tip-longbeach-width .callout-tip}

## 너비 선택

종종 너비 선택은 물리적 제약에 따라 달라질 수 있습니다. 예를 들어 이 책의 시각화는 모두 인쇄판 페이지에 맞게 약 5인치 너비입니다. 여러 크기의 이미지(예: 저해상도 및 고해상도)를 원할 수도 있습니다.

플롯의 너비(또는 해상도)를 변경하면 종종 글꼴 크기와 같이 반드시 더 크게 재조정되지 않는 다른 측면도 변경해야 함을 의미합니다. `base_size`를 설정하고 `rel()`을 사용하여 개별 글꼴 크기 요소를 편집하면 작업량을 최소화할 수 있습니다. 원하는 크기와 해상도로 플롯을 보면 크기를 올바르게 설정하기가 더 쉽습니다. 자세한 내용은 @sec-camcorder 를 참조하십시오.

:::

### 전통적인 범례의 대안

플롯의 높이를 늘려 연도 레이블이 찌그러지는 것을 막을 수도 있지만 대안적인 접근 방식은 문제의 근원을 해결하고 범례를 편집하는 것입니다.

범례를 처리하는 데는 몇 가지 다른 옵션이 있습니다. 

* 범례를 그대로 두되 오른쪽이 아닌 주 차트 위나 아래로 위치를 변경하고 한 줄로 만듭니다. 그러면 공간을 덜 차지할 것입니다. 범례 위치 변경은 @sec-doctors 에서 논의할 것입니다.

* 사용자 정의 범례를 디자인할 수 있습니다. 이중 게이지 차트는 흔하지 않고 독자에게 생소할 수 있으므로 이 옵션이 좋을 수 있습니다. 작동 방식에 대한 추가 정보를 추가하면 도움이 될 수 있습니다. @sec-time-zones 및 @sec-house 에서 사용자 정의 범례를 디자인하고 사용하는 방법을 살펴보겠습니다.

* 대신 부제목에 색상 텍스트를 사용하여 범주가 무엇인지 나타낼 수 있습니다. 이 시각화의 경우 진한 분홍색 범주를 강조 표시하고 설명하는 것으로 충분할 것입니다. R에서 이를 수행하는 방법은 @sec-turbines 및 @sec-cats 에서 살펴보겠습니다.

여기에는 어떤 형태의 범례도 사실상 불필요하다는 주장이 있을 수 있습니다. 현재의 색상 선택과 차트 제목은 진한 분홍색이 데이터의 동물 수(목표에 대한 백분율)를 나타낸다는 것을 충분히 명확하게 보여줍니다.

따라서 `theme()` 내부에서 `legend.position = "none"`을 설정하여 범례를 제거해 봅시다. \index{ggplot2!theme}

```{r}
#| label: fig-longbeach-style-3
#| fig-cap: "Final styling of gauge chart to remove the legend, providing more space for the chart area."
#| fig-alt: "Final styling of gauge chart to remove the legend, providing more space for the chart area."
styled_plot +
  theme(legend.position = "none")
```

그런 다음 `ggsave()`로 저장합니다: \index{ggplot2!ggsave}

```{r}
#| label: longbeach-save
#| eval: false
#| echo: true
ggsave(
  filename = "animal-intakes.png",
  width = 5,
  height = 0.7 * 5
)
```

## 성찰

게이지 차트가 이 데이터를 시각화하는 가장 효과적인 방법일까요? 아니요. 게이지 차트에는 고유한 문제가 있으며 그중 일부를 여기에서 볼 수 있습니다. 2023년을 나타내는 링이 바깥쪽에 있으므로 반지름이 더 크고 따라서 면적도 더 큽니다. 2017년과 2023년 사이의 호 길이 변화를 측정하면 이 두 가지에 대한 면적의 비례적 변화를 측정했을 때와 다른 답을 얻을 수 있습니다. 여기서는 2023년 값이 2017년 값보다 일관되게 낮지만 더 많은 공간을 차지합니다. 게이지 차트 아이디어를 고수한다고 가정할 때 이 플롯을 개선하기 위해 어떤 추가 변경을 할 수 있을까요?

* 패싯 레이블을 좀 더 멋지게 서식을 지정할 수 있습니다(예: 대문자 사용, *wild* 대신 *wild animals* 사용). 패싯을 전체적으로 가장 높은 것에서 가장 낮은 것으로 정렬하면 읽기가 얼마나 쉬운지도 향상될 것입니다.

* 정확한 수를 레이블 텍스트로 제공하면 입소의 변화를 보기가 더 쉬워질 것입니다. 6가지 동물 유형 모두에서 감소가 있었음이 합리적으로 명확하지만 게이지 차트의 특성(그리드 선 없음)으로 인해 정확한 값을 얻기가 꽤 어렵습니다. 2017년에 개와 고양이의 차이점은 무엇입니까? 여기서는 말하기가 너무 어렵습니다.

* 현재 선택이 다소 임의적으므로 상한에 대해 더 직관적인 값을 얻고 사용합니다. 찾을 수 없다면 슬로프 차트와 같은 더 간단한 차트 유형으로 돌아가는 더 많은 동기가 될 수 있습니다.

* 여기서는 전체적인 전통적 범례가 불필요할 수 있지만 색상 텍스트를 추가하면 분홍색 영역이 주요 데이터를 나타낸다는 설명이 추가될 수 있습니다. @sec-turbines 및 @sec-cats 에서 전설 대신 색상 텍스트를 사용하는 것을 살펴보겠습니다.

## 연습 문제

* 게이지 차트 대신 막대 차트를 사용하여 이 시각화를 다시 디자인하고 차트에 직접 백분율 값을 표시하는 레이블을 추가하십시오.

* 레이아웃을 개선하기 위해 종횡비나 좌표계를 변경해야 합니까?
