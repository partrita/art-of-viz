---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.5
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
library(sysfonts)
```

```{r}
#| echo: false
#| eval: true
#| file: R/load_font_awesome.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/social_caption.R
```

# 미국 하원 선거: **`geofacet`**을 이용한 그리드 위의 지리 {#sec-house}

이 장에서는 **`geofacet`**을 사용하여 지리적 영역과 유사한 그리드에 패싯 플롯을 배열하는 방법을 배우고, 사용자 정의 범례를 만드는 또 다른 접근 방식을 살펴봅니다. \index{geofacet} \index{patchwork}

이 장을 마치면 다음을 할 수 있습니다:

* 미국 주 수준 데이터의 작은 다중 플롯(small multiple plots)을 주(state)의 기본 지리를 반영하는 그리드에 배열합니다;
* 패싯 레이블을 더 크고 반투명한 사용자 정의 주석으로 대체합니다;
* 더 미니멀한 작은 다중 플롯을 위해 확대된 *이 플롯을 읽는 방법* 범례를 만듭니다.

이 장에서 필요한 패키지를 로드하는 것으로 시작합니다.

```{r}
#| label: elections-pkgs-req
#| warning: false
#| message: false
library(dplyr)
library(geofacet)
library(ggplot2)
library(ggtext)
library(glue)
library(patchwork)
library(showtext)
library(sysfonts)
library(tidyr)
library(tidytuesdayR)
```

이 장에서는 지리적 영역의 모양으로 플롯 그리드를 배열하는 데 사용되는 **`geofacet`**이라는 새로운 패키지를 하나만 소개합니다. 이 패키지에는 다양한 국가 및 지역에 대한 미리 정의된 그리드가 많이 포함되어 있지만 자신만의 사용자 정의 그리드를 만들 수도 있습니다. \index{geofacet}

## 데이터

MIT Election Data and Science Lab은 미국 민주주의를 개선하기 위해 미국 선거에 대한 데이터와 결과를 수집, 분석 및 공유합니다. 여기에는 선거구 수준의 미국 하원 선거에 대한 데이터가 포함됩니다 [@elections_data]. 데이터는 정기적으로 업데이트되며, 1976년부터 2022년까지의 선거 정보가 포함된 이 데이터 세트 버전은 [2023년 11월 TidyTuesday 데이터 세트](https://github.com/rfordatascience/tidytuesday/tree/main/data/2023/2023-11-07)로 사용되었습니다. **`tidytuesdayR`**의 `tt_load()` 함수를 사용하여 데이터를 다시 로드할 수 있습니다: \index{TidyTuesday} \index{tidytuesdayR!tt\_load}

```{r}
#| label: elections-load-data-show
#| eval: false
#| echo: true
tuesdata <- tt_load("2023-11-07")
house <- tuesdata$house
```

```{r}
#| label: elections-load-data-hide
#| output: false
#| echo: false
#| eval: true
house <- readr::read_csv("data/house.csv")
```

데이터에는 `r nrow(house)`개의 행과 `r ncol(house)`개의 열이 있습니다. `head()`(또는 선호하는 경우 `View()`)를 사용하여 데이터의 처음 몇 행을 살펴봅시다: \index{utils!head}

```{r}
#| label: elections-head-data
head(house)
```

많은 `state` 열이 있으며, 본질적으로 다른 형식으로 유사한 정보를 제공합니다. 예를 들어 `state` 열은 주 이름을 제공하고 `state_po` 열은 주의 두 글자 약어를 제공합니다. 또한 주 내의 선거구(지구)를 식별하는 열도 있습니다. 데이터는 후보자에 대한 정보(이름, 소속 정당, 출마한 선거에서 받은 득표 수)를 제공합니다. 다른 열은 총 투표 수, 선거 단계, 재보궐 선거 여부, 결선 투표 여부 등 선거에 대한 정보를 제공합니다. `version` 열에는 데이터의 릴리스 버전을 식별하는 데이터가 포함되어 있습니다.

## 탐색 작업

`house` 데이터는 매우 세분화되어 있어 하나의 차트에 모든 정보를 시각화하기는 어렵습니다. 따라서 데이터를 하위 집합화하거나 집계하는 다양한 방법을 생각해 볼 수 있습니다. 다음에 초점을 맞출 수 있습니다:

* 주: 특정 주 내의 투표 패턴을 살펴보거나 선거구 수준 대신 주 수준 데이터를 살펴보도록 집계할 수 있습니다.

* 정당: 후보자가 여러 정당을 대변하는 퓨전 티켓(fusion tickets)에 대한 데이터를 포함하여 각 후보자가 어느 정당에 출마했는지에 대한 정보가 있습니다.

* 시간: 데이터는 1976년부터 2022년까지 제공되며, 시간 경과에 따른 득표율 또는 득표 수 추세를 살펴볼 수 있습니다.

### 데이터 탐색

시간이 지남에 따라 투표 수가 변경되었는지 여부를 간략하게 살펴보는 것으로 시작하겠습니다. 데이터는 1976년으로 거슬러 올라가며 미국의 인구는 1970년과 2020년 인구 조사 사이에 150% 이상 증가했으므로 [@UScensuspop] 투표 수에서도 비슷한 증가를 예상할 수 있을까요? `plot()`으로 만든 빠른 산점도로 시간 경과에 따른 후보자 투표 수를 살펴보는 것으로 시작하겠습니다:

```{r, echo=-1}
#| label: fig-elections-scatterplot
#| fig-cap: "시간에 따른 후보자 득표 수를 보여주는 산점도로, 선거가 2년마다 실시되며 시간이 지나도 큰 변화가 없음을 분명히 알 수 있습니다."
#| fig-alt: "시간에 따른 후보자 득표 수를 보여주는 산점도로, 선거가 2년마다 실시되며 시간이 지나도 큰 변화가 없음을 분명히 알 수 있습니다."
#| fig-asp: 0.8
par(mar = c(4.1, 4.1, 2.1, 2.1), cex.axis = 0.6, cex.names = 0.6)
plot(
  x = house$year,
  y = house$candidatevotes,
  xlab = "",
  ylab = "후보자 득표 수"
)
```

@fig-elections-scatterplot 의 시간 경과에 따른 투표 수에는 적어도 언뜻 보기에는 특별히 흥미로운 패턴이 없는 것 같습니다. 그러나 잠재적인 데이터 문제를 강조했습니다. 대부분의 연도에서 가장 높은 값은 약 300,000이지만 2022년에는 1,000,000이 넘는 두 개의 관측치가 있습니다. @sec-bees 에서도 비슷한 문제가 있었는데, 일부 관측치가 다른 관측치의 합계였습니다. 여기서는 그런 것 같지 않습니다. 지금은 이들을 제외하고 후보자 투표 수가 600,000 미만인 데이터를 살펴봅시다.

또한 정당별로 후보자 투표 수가 어떻게 다른지 관심이 있을 수 있으며 `boxplot()` 함수를 사용하여 큰 차이가 있는지 알아볼 수 있습니다: \index{graphics!boxplot}

```{r, echo=-1}
#| label: fig-elections-boxplot
#| fig-cap: "각 정당의 후보자 득표 수를 보여주는 상자 그림으로, 고유한 정당 수가 많기 때문에(득표 수가 적음) 많은 정당 레이블이 숨겨져 있습니다."
#| fig-alt: "각 정당의 후보자 득표 수를 보여주는 상자 그림으로, 고유한 정당 수가 많기 때문에(득표 수가 적음) 많은 정당 레이블이 숨겨져 있습니다."
#| fig-asp: 1.2
par(mar = c(4.1, 7.1, 1.1, 1.1), cex.axis = 0.4, cex.names = 0.4)
boxplot(
  candidatevotes ~ party,
  data = house[house$candidatevotes < 600000, ],
  horizontal = TRUE,
  las = 1,
  xlab = "후보자 득표 수",
  ylab = NULL
)
```

@fig-elections-boxplot 에는 주목할 만한 몇 가지 흥미로운 점이 있습니다. 첫째, 모든 무소속 후보가 다른 정당 이름으로 나열되기 때문에 고유한 `party` 이름이 매우 많습니다. 즉, 모든 정당 이름을 차트에서 실제로 읽을 수는 없습니다. 둘째, 데이터에 표시된 이상값이 많아 데이터가 매우 치우쳐 있습니다. 마지막으로, 다른 정당보다 득표 수가 훨씬 많은 두 정당이 있습니다. 데이터를 조사하면 짐작할 수 있듯이 민주당과 공화당임을 알 수 있습니다.

### 탐색적 스케치

이 기간 동안 민주당과 공화당이 선거를 지배했습니다. 숫자가 너무 적기 때문에 개별 무소속 후보에 대한 신뢰할 수 있는 통찰력을 도출할 수 없을 것이므로 다른 모든 정당 후보를 *기타(other)* 범주로 묶어 봅시다. @fig-elections-scatterplot 과 @fig-elections-boxplot 을 결합하고 각 주에 대한 정보와 함께 시간과 공간에 따른 주요 정당의 득표율 변화 패턴이 있는지 살펴볼 수 있습니다.

민주당, 공화당 및 기타 정당의 득표율을 보여주는 주별로 패싯된 영역 차트(area chart)를 만드는 것을 고려할 수 있습니다. 지리적으로 가까운 주는 유사한 패턴을 보일 가능성이 더 큽니다. 패싯된 영역 차트를 직사각형 그리드에 배열하는 대신 지리적 위치를 기반으로 배열하는 것이 더 합리적일 것입니다. 이렇게 하면 주 간의 패턴을 더 쉽게 비교할 수 있습니다. @fig-elections-sketch 는 이것이 어떤 모습일지 보여주는 예입니다:

![미국 모양의 그리드에 배열된 패싯 영역 차트의 초기 스케치.](images/sketch-elections.png){#fig-elections-sketch fig-align="center" fig-alt="미국 모양의 그리드에 배열된 패싯 영역 차트의 초기 스케치."}

종종 패싯 차트에서는 x축과 y축이 여러 번 표시됩니다. 이로 인해 차트가 특히 이러한 지리적 레이아웃을 사용할 때 지나치게 *복잡해(busy)* 보일 수 있습니다. @sec-turbines 및 @sec-lemurs 에서 했던 것처럼 매우 미니멀한 패싯 차트 세트를 만들고 색상 텍스트를 범례로 사용할 수 있습니다. 미니멀한 접근 방식이 더 깔끔해 보일 수 있지만 차트에 무엇이 표시되어 있는지 명확하지 않을 수도 있습니다. 패싯 플롯 중 하나의 확대 버전으로 만든 *이 차트를 읽는 방법* 설명자를 범례로 추가해 봅시다: \index{area chart}

![미국 모양의 그리드에 배열된 패싯 영역 차트의 초기 스케치. 영역 차트 하나의 확대 버전이 왼쪽의 범례로 사용됩니다.](images/sketch-elections-2.png){#fig-elections-sketch-2 fig-align="center" fig-alt="미국 모양의 그리드에 배열된 패싯 영역 차트의 초기 스케치. 영역 차트 하나의 확대 버전이 왼쪽의 범례로 사용됩니다."}

## 플롯 준비

@fig-elections-sketch-2 를 구현하려면 *기타* 정당을 집계하고 정당, 연도 및 주별로 투표 수를 계산하는 것으로 시작해야 합니다.

### 데이터 랭글링

*기타* 정당을 집계하기 위해 **`dplyr`**의 `mutate()`를 사용하여 기존 `party` 열을 업데이트합니다. `case_when()`을 사용하여 새로운 정당 범주를 만들고 두 주요 정당에 대해 약간 더 나은 대체 레이블을 제공할 기회를 잡습니다. \index{dplyr!mutate} \index{dplyr!case\_when}

`stage` 열에는 선거가 총선(`"GEN"`)인지 예비 선거(`"PRI"`)인지에 대한 정보가 포함되어 있습니다. 내용을 단순하게 유지하기 위해 **`dplyr`**의 `filter()`를 사용하여 데이터를 총선으로만 제한합니다. 그런 다음 `group_by()` 및 `summarise()`를 사용하여 각 연도, 주 및 정당 범주의 투표 수를 합산합니다. 마지막에는 데이터의 그룹 해제(`ungroup()`)를 기억하십시오! \index{dplyr!filter} \index{dplyr!group\_by} \index{dplyr!summarise} \index{dplyr!ungroup}

```{r}
#| label: elections-wrangling
house_data <- house |>
  mutate(party = case_when(
    party == "REPUBLICAN" ~ "공화당",
    party == "DEMOCRAT" ~ "민주당",
    TRUE ~ "기타"
  )) |>
  filter(stage == "GEN") |>
  group_by(year, state_po, party) |>
  summarise(votes = sum(candidatevotes)) |>
  ungroup()
```

일부 주에서는 `"other"` 후보가 없는 연도가 있으므로 이러한 값에 대한 행이 없습니다. 즉, 암시적으로 누락된 것입니다. @sec-r-pkgs 에서 보았듯이 이로 인해 오해의 소지가 있는 영역 차트가 생성되고 **`ggplot2`**에서 경고가 발생할 수 있습니다. @sec-r-pkgs 에서와 같이 이러한 *누락된* 값은 실제로 누락된 것이 아니라 단순히 0입니다. 이전에 했던 것처럼 **`tidyr`**의 `complete()`를 사용하여 `year`, `state_po` 및 `party`의 모든 조합이 데이터에 존재하도록 하고 *누락된* 조합을 명시적으로 0으로 설정합니다. \index{tidyr!complete}

```{r}
#| label: elections-wrangling2
plot_data <- house_data |>
  complete(
    year, state_po, party,
    fill = list(votes = 0)
  )
```

### 첫 번째 플롯

@sec-programming, @sec-museums, 및 @sec-longbeach 에서 했던 것처럼 다시 패싯 플롯을 만들 것입니다. 이 플롯에는 두 가지 주요 차이점이 있습니다:

* 플롯을 지정된 수의 행과 열이 있는 직사각형 모양으로 배열하는 대신 기본 지리(geography)와 유사한 방식으로 플롯을 배열하려고 합니다.
* 이전에 만든 플롯(대부분 10개 미만)에 비해 훨씬 더 많은 패싯(50개 이상)이 있습니다. 때로는 많은 수의 패싯을 만드는 것이 느릴 수 있습니다.

두 번째 문제 때문에 패싯 플롯을 개발할 때, 특히 대규모 데이터나 복잡한 시각화를 사용할 때 단일 플롯을 먼저 만드는 것이 유용할 수 있습니다. 즉, 데이터를 필터링하고 패싯 범주의 한 수준에 대해서만 차트를 만듭니다. 이렇게 하면 패싯 레이아웃에 대해 걱정하기 전에 차트의 기본 사항을 올바르게 설정할 수 있습니다.

캘리포니아로만 데이터를 하위 집합화하는 **`dplyr`**의 `filter()` 함수로 감싼 `plot_data`를 `ggplot()`의 `data` 인수에 전달하는 것으로 시작합니다. 정당별로 나누어 x축에는 연도를, y축에는 득표 수를 플롯하도록 미적 매핑을 설정합니다. \index{dplyr!filter} \index{ggplot2!ggplot} \index{ggplot2!aes}

@sec-museums 및 @sec-r-pkgs 에서 영역 차트를 만드는 예를 이미 보았지만 이 장에서는 약간의 변경을 줄 것입니다. 주(각각 인구 규모가 매우 다르므로 득표 수가 매우 다름)를 비교할 것이므로 득표 수의 영역 차트를 고려하는 대신 각 정당의 비율을 살펴볼 것입니다. 다행히도 `geom_area()` 내부에서 `position = "fill"`을 설정하면 이 작업이 수행되므로 이러한 백분율을 직접 계산할 필요가 없습니다. \index{ggplot2!geom\_area}

```{r}
#| label: fig-elections-single-plot
#| fig-cap: "캘리포니아의 다양한 정당 범주에 대한 득표율을 보여주는 영역 차트. 기본 색상, 스타일 및 범례가 적용되었습니다."
#| fig-alt: "캘리포니아의 다양한 정당 범주에 대한 득표율을 보여주는 영역 차트. 기본 색상, 스타일 및 범례가 적용되었습니다."
#| warning: false
basic_plot <- ggplot(
  data = filter(plot_data, state_po == "CA")
) +
  geom_area(
    mapping = aes(
      x = year, y = votes, fill = party
    ),
    position = "fill"
  )
basic_plot
```

이제 패싯 값 중 하나에 대한 기본 플롯이 생겼습니다.

::: {#tip-elections-piping .callout-tip}

## 데이터를 `ggplot()`으로 파이핑하기

`ggplot`의 첫 번째 인수는 `data`이므로 데이터를 첫 번째 인수로 명시적으로 명시하는 대신 `ggplot()` 함수로 파이핑할 수 있다는 의미입니다. 예를 들어 위의 코드는 다음과 같이 다시 쓸 수 있습니다:

```{r}
#| label: elections-plot-piping
#| eval: false
#| echo: true
plot_data |>
  filter(state_po == "CA") |>
  ggplot() +
  geom_area(
    mapping = aes(
      x = year, y = votes, fill = party
    ),
    position = "fill"
  )
```

이것은 `ggplot()` 내부에 `filter()`를 중첩하는 것보다 더 깔끔해 보일 수 있지만, 두 가지 이유로 `ggplot()`으로 파이핑하는 다른 예를 볼 가능성은 낮습니다:

* `+`와 `|>`의 조합은 이상하게 보이며, 파이핑으로 인한 깔끔함보다 더 큽니다(개인적인 의견).
* 매우 길고 복잡한 코드로 끝나는 것이 더 쉬워집니다. 데이터 랭글링과 플롯 코드를 분리하는 것이 종종 더 합리적입니다.

:::

이제 전체 데이터를 `ggplot()`에 전달(캘리포니아 하위 집합이 아님)하고 `facet_wrap()`을 추가하여 `state_po`의 각 값에 대한 영역 차트를 만들 수 있습니다. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_area} \index{ggplot2!facet\_wrap}

```{r}
#| label: fig-elections-basic-plot
#| fig-cap: "직사각형 그리드 모양으로 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 패싯 레이블의 크기로 인해 영역 차트를 볼 수 없습니다."
#| fig-alt: "직사각형 그리드 모양으로 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 패싯 레이블의 크기로 인해 영역 차트를 볼 수 없습니다."
#| warning: false
#| source-line-numbers: "2,11"
basic_plot <- ggplot(
  data = plot_data
) +
  geom_area(
    mapping = aes(
      x = year, y = votes, fill = party
    ),
    position = "fill"
  )
basic_plot +
  facet_wrap(~state_po)
```

@fig-elections-basic-plot 에서는 실제로 영역 차트를 볼 수 없고 패싯 레이블만 볼 수 있습니다. 이는 패싯 범주의 수가 많고 차트 크기가 작을 때 매우 일반적인 문제입니다. 플롯 테마를 조정할 때 이 문제를 조금 더 다룰 것입니다.

### **`geofacet`**으로 패싯하기

패싯 플롯을 기본 지리와 유사한 그리드로 배열하기 위해 **`geofacet`** 패키 [@geofacet]를 사용합니다. **`geofacet`** 패키지를 사용하면 패싯을 지도 모양으로 쉽게 배열할 수 있습니다. 이를 통해 주나 국가와 같은 지역의 데이터를 그리드 형식으로 더 쉽게 비교할 수 있습니다. 미국을 위한 여러 그리드를 포함하여 다양한 지리적 지역에 대한 내장 그리드가 많이 있습니다. 그러나 다른 레이아웃을 선호하거나 플롯하려는 지역에 대한 그리드가 없는 경우 자신만의 사용자 정의 패싯 그리드를 만들 수도 있습니다.

**`geofacet`**으로 패싯을 수행하려면 `facet_wrap()` 대신 `facet_geo()`를 사용합니다. 기본적으로 같은 방식으로 작동하며 `~`를 사용하여 패싯 컬럼을 지정하는 것으로 시작합니다. 그러나 약간 다른 점이 두 가지 있습니다: \index{geofacet!facet\_geo} \index{geofacet!facet\_geo}

* 어떤 그리드 레이아웃을 사용할지 지정해야 합니다. **`geofacet`**의 `get_grid_names()` 함수를 사용하여 유효한 모든 그리드 이름 목록을 얻을 수 있습니다. 그리드 이름은 그리드가 어떤 지역에 대한 것인지에 따라 합리적으로 지정됩니다. 예를 들어 `"us_state_grid1"` 및 `"eu_grid1"`입니다. 여기서는 `"us_state_grid2"`를 사용합니다.

* 데이터를 그리드의 올바른 패싯 위치에 매핑하려면 데이터의 열 중 하나가 선택한 그리드의 `code` 열에 있는 값과 일치해야 합니다. `"us_state_grid2"` 그리드에서 `code` 열에는 데이터의 `state_po` 열과 일치하는 두 글자 주 약어가 포함되어 있습니다. 두 글자 약어가 없는 경우 이를 첨부하기 위해 데이터 결합을 수행해야 할 수도 있습니다.

추가 *주*(예: 푸에르토리코는 주가 아니더라도 미국 주 열에 나열될 수 있음)가 있거나 일부 주가 누락된 경우에도 `facet_geo()`를 사용할 수 있습니다. 그러나 패싯 그리드에 나열된 주만 플롯하고 경고 메시지를 받을 수 있습니다.

```{r}
#| label: fig-elections-geofacet-plot
#| fig-cap: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 패싯 레이블의 크기로 인해 영역 차트를 볼 수 없습니다."
#| fig-alt: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 패싯 레이블의 크기로 인해 영역 차트를 볼 수 없습니다."
#| warning: false
map_plot <- basic_plot +
  facet_geo(
    ~state_po,
    grid = "us_state_grid2"
  )
map_plot
```

여전히 차트의 세부 정보를 볼 수 없다는 동일한 문제가 있지만 패싯 제목만 봐도 플롯이 이제 미국과 유사한 그리드에 배열되어 있음을 알 수 있습니다.

## 고급 스타일링

이제 더 직관적인 색상을 적용하고, 차트를 더 쉽게 볼 수 있도록 패싯 레이블을 조정하고, 이 차트를 읽는 방법을 설명하는 사용자 정의 범례를 만들도록 차트 스타일을 지정합니다.

### 색상

미국에서 공화당은 빨간색으로, 민주당은 파란색으로 표시됩니다. @sec-lemurs 에서 논의했듯이 잘 알려진 범주에 사용할 색상을 선택할 때 부정적인 고정 관념(예: 여자는 분홍색)을 재생산하지 않는 것이 중요합니다. 그러나 직관적인 것을 사용하는 것도 중요합니다. 이들은 정당이 자신을 나타내기 위해 선택한 색상이고 매우 잘 알려져 있으므로 빨간색과 파란색을 고수할 것입니다. \index{color}

시각화가 이미 꽤 복잡하므로 배경색을 매우 단순하게 유지하여 흑백만 사용합니다.

```{r}
#| label: elections-colors
blue_col <- "#0015BC"
red_col <- "#C41E3A"
other_col <- "#AAAAAA"
text_col <- "black"
bg_col <- "white"
```

그런 다음 `scale_fill_manual()`을 사용하여 플롯에 색상을 적용하고 `values`의 관련 정당 레이블에 각 색상을 할당할 수 있습니다. 나중에 자체 범례를 만들 것이므로 `guide = "none"`을 설정하여 기본 범례를 제거합니다. \index{ggplot2!scale\_fill\_manual}

```{r}
#| label: elections-add-colors
#| warning: false
col_plot <- map_plot +
  scale_fill_manual(
    values = c(
      "민주당" = blue_col,
      "공화당" = red_col,
      "기타" = other_col
    ),
    guide = "none"
  )
```

### 텍스트 및 글꼴

이전 장에서와 같이 **`sysfonts`** 및 **`showtext`** 패키지를 사용하여 서체를 정의할 수 있습니다. 기본 글꼴의 경우 @sec-doctors 에서 했던 것처럼 *Roboto* 서체를 사용합니다. 제목 텍스트의 경우 20세기 중반 광고에 사용된 서체에서 영감을 받은 [Vernon Adams가 디자인한 디스플레이 글꼴](https://fonts.google.com/specimen/Carter+One)인 *Carter One*을 사용합니다. 시각화 제목에 잘 어울리는 굵은 서체입니다. \index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: elections-fonts
font_add_google(name = "Roboto")
font_add_google(
  name = "Carter One", family = "Carter"
)
font_add_google(name = "Noto Sans KR", family = "noto_sans_kr")
showtext_auto()
showtext_opts(dpi = 300)
body_font <- "Roboto"
title_font <- "Carter"
korean_font <- "noto_sans_kr"
```

@sec-cats 와 @sec-lemurs 에서 했던 것처럼 색상 텍스트에 HTML 스타일링을 추가하기 위해 `glue()`를 사용하여 부제목에 대한 텍스트를 작성합니다. 색상 텍스트는 범례 역할을 하며(나중에 우리만의 사용자 정의 범례도 추가할 예정이지만), 부제목 텍스트는 차트가 보여주는 내용에 대한 정보를 제공합니다. 색상 텍스트는 읽기 쉽도록 굵은 텍스트로 서식을 지정합니다. @sec-time-zones 에서와 같이 데이터 소스에 대한 정보를 캡션이 아닌 부제목 끝줄에 추가합니다. 또한 @sec-time-zones 에서 했던 것처럼 텍스트 배치를 용이하게 하기 위해 제목 텍스트를 부제목 변수에 직접 추가합니다. \index{glue!glue}

```{r}
#| label: elections-text
st <- glue("<span style='font-size:10pt; font-family:{title_font}; color:{text_col};'>미국 하원 선거 득표 현황</span><br>영역 차트는 1976년부터 2022년까지의 총선에서 <span style='color:{blue_col};'>**민주당**</span>, <span style='color:{red_col};'>**공화당**</span>, 및 <span style='color:#aaaaaa;'>**기타**</span> 정당의 득표율을 나타냅니다.<br><br>**데이터**: 미국 하원 1976–2022. MIT Election Data and Science Lab.")
```

@sec-cats 에서 정의한 `social_caption()` 함수도 사용하며, 나중에 플롯 캡션으로 추가할 것입니다: \index{social\_caption}

```{r}
#| label: elections-text-2
social <- social_caption(
  icon_color = blue_col,
  font_color = text_col,
  font_family = body_font
)
```

그런 다음 부제목과 캡션 텍스트를 `labs()` 함수에 전달하여 플롯에 추가합니다. 부제목 텍스트를 일반적이지 않은 위치에 배치하려고 하므로 @sec-time-zones 에서 했던 것과 유사하게 `subtitle`보다는 `tag` 인수를 사용합니다. \index{ggplot2!labs} 

```{r}
#| label: elections-labs
text_plot <- col_plot +
  labs(
    tag = st,
    caption = social
  )
```

### 테마 조정

@fig-elections-geofacet-plot 에서 볼 수 있듯이 패싯 레이블이 너무 크고 현재 시각화를 지배하고 있다는 것을 알고 있습니다. 이에 대한 몇 가지 해결책이 있습니다:

* 패싯 레이블을 훨씬 작게 만듭니다. 그러나 이렇게 하면 읽기 어렵고 레이블이 다소 무의미해질 수 있습니다.

* 차트의 크기를 늘립니다. 여기서는 플롯의 물리적 너비에 제약을 받으므로 더 넓게 만들 수 없습니다. 플롯을 더 높게 만들 수는 있지만 단순히 레이블을 위해 꽤 많은 추가 공간을 추가하게 됩니다.

* 우리만의 사용자 정의 패싯 레이블을 만듭니다.

여기서는 세 번째 옵션을 선택하겠습니다. 나중에 `theme()` 함수를 사용하여 기본 패싯 레이블을 제거할 것입니다. 지금은 어떤 레이블을 추가할지 생각해 봅시다. 플롯의 공간을 절약하는 가장 쉬운 방법은 내부 패싯 레이블을 사용하는 것입니다(주 레이블을 영역 차트 내부에 배치). 이는 데이터의 일부를 숨기는 단점이 있습니다. 그러나 텍스트를 반투명하게 만들어 주 레이블과 뒤에 있는 영역 차트를 모두 볼 수 있도록 할 수 있습니다.

`geom_text()`로 텍스트 레이블을 추가합니다. 텍스트의 x 좌표 위치는 차트 중간에 자동으로 배치되도록 전체 `plot_data` 데이터의 연도 평균으로 설정됩니다. y 좌표 위치는 `0.5`로 설정됩니다. 즉, `position = "fill"` 인수가 y축을 `0`과 `1` 사이로 조정하므로 역시 차트의 중간입니다. `alpha()` 함수는 텍스트 색상의 투명도를 제어하는 데 사용됩니다. \index{ggplot2!geom\_text}  \index{ggplot2!aes} \index{ggplot2!alpha}

여기서 `alpha()`에 평소보다 훨씬 작은 값을 사용한다는 점에 유의하십시오. 이는 실제로 각 연도 및 정당 조합에 대해 하나씩, 여러 레이블이 서로 겹쳐서 그려지기 때문입니다. 이것이 반드시 문제는 아니지만 반투명 레이블을 만들려는 경우 동일한 반투명 레이블을 여러 장 겹쳐 놓으면 꽤 불투명한 레이블이 됩니다. 데이터 하나만 필터링하여 한 연도와 정당만 고려할 수도 있지만 **`geofacet`** 패키지는 때때로 이 접근 방식으로 레이블을 올바르게 렌더링하는 데 문제가 있습니다.

```{r}
#| label: elections-geofacet-style-1
#| warning: false
styled_plot_1 <- text_plot +
  geom_text(
    mapping = aes(
      x = mean(range(plot_data$year)),
      y = 0.5,
      label = state_po
    ),
    family = title_font,
    color = alpha(bg_col, 0.02),
    size = 2.5
  )
```

이전 장에서 했던 것처럼 `coord_cartesian()` 내부에서 `expand = FALSE`를 설정하여 각 플롯 패널 주변의 추가 공간을 제거합니다. 또한 미니멀한 모양을 목표로 하고 있으며 나중에 독자에게 일반적으로 축 레이블과 제목으로 전달되는 모든 정보를 제공하는 사용자 정의 범례를 디자인할 것이므로 `theme_void()`를 사용하여 추가 플롯 요소를 제거합니다. \index{ggplot2!theme\_void} \index{ggplot2!coord\_cartesian}

이전 장에서와 같이 `element_rect()` 함수를 사용하여 `plot.background`를 미리 정의된 배경색 변수로 설정합니다. 또한 `plot.margin`을 사용하여 플롯 여백을 조정합니다. 여기서는 왼쪽 플롯 여백을 매우 크게 만드는데, 여기에 사용자 정의 범례를 배치할 것이기 때문입니다. @sec-lemurs 에서 이 접근 방식의 장단점에 대해 논의했습니다. \index{ggplot2!theme} \index{ggplot2!element\_rect} \index{ggplot2!margin} \index{ggplot2!unit} \index{ggplot2!rel}

`hjust`에 음수 값을 선택하여 제목 텍스트를 플롯의 왼쪽, 넓은 여백에 배치할 수 있습니다. `0`은 왼쪽 정렬을 의미하고 `1`은 오른쪽 정렬을 의미한다는 것을 기억하십시오. 음수 값은 본질적으로 *매우 왼쪽 정렬*을 의미합니다! 제목이 한 줄의 텍스트이기 때문에 여기서는 잘 작동하지만 여러 줄의 텍스트의 경우 텍스트 정렬이 이상하게 보일 수 있습니다. 즉, 부제목 텍스트(짧은 단락)의 경우 `subtitle` 대신 `tag` 텍스트를 사용합니다. `plot.tag.position`을 사용하면 텍스트가 표시될 좌표 벡터를 지정할 수 있으며 음수 x 좌표를 사용하여 텍스트를 넓어진 플롯 여백에 배치할 수도 있습니다. `title`과 `tag` 텍스트가 서로 정렬되도록 하려면 약간의 시행착오가 필요합니다. 플롯 `tag` 텍스트에 대한 자동 텍스트 줄 바꿈을 활성화하고 아이콘이 올바르게 렌더링되도록 캡션에 대해 `element_textbox_simple()`을 다시 사용합니다. \index{ggtext!element\_textbox\_simple}

`strip.background` 및 `strip.text` 인수를 모두 `element_blank()`로 설정하여 모든 기본 패싯 레이블을 제거하고 `panel.spacing`을 사용하여 패싯 사이의 간격을 제어하고 더 가깝게 이동합니다. \index{ggplot2!element\_blank} 

```{r}
#| label: fig-elections-plot-style-2
#| fig-cap: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 왼쪽에 큰 빈 공간이 나타나며 여기에 나중에 범례가 배치됩니다."
#| fig-alt: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 왼쪽에 큰 빈 공간이 나타나며 여기에 나중에 범례가 배치됩니다."
#| warning: false
styled_plot_2 <- styled_plot_1 +
  coord_cartesian(expand = FALSE) +
  theme_void(base_size = 6, base_family = body_font) +
  theme(
    # Background elements
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    plot.margin = margin(5, 5, 5, 125),
    plot.tag = element_textbox_simple(
      family = korean_font,
      hjust = 0,
      color = text_col,
      maxwidth = 0.65,
      lineheight = 0.6,
      size = rel(1.0)
    ),
    plot.caption = element_textbox_simple(
      family = korean_font,
      hjust = 1,
      halign = 1,
      color = text_col,
      maxwidth = 0.65,
      margin = margin(b = 0, t = 10)
    ),
    plot.tag.position = c(-0.50, 0.77),
    # Facet arguments
    strip.background = element_blank(),
    strip.text = element_blank(),
    panel.spacing = unit(0.05, "lines")
  )
styled_plot_2
```


### 사용자 정의 범례 개발
 
@sec-time-zones 에서 했던 것처럼 사용자 정의 범례를 디자인할 것입니다. @sec-time-zones 에서는 막대 차트를 범례로 사용했는데, 이는 시각화의 또 다른 정보 소스 역할도 했습니다. 이 장에서 사용자 정의 범례는 그 대신 *이 차트를 읽는 방법* 설명자 역할을 할 것입니다. \index{legend}

패싯 중 하나를 가져와 확대하고 차트에 어떤 데이터가 표시되는지 설명하는 주석을 추가할 수 있습니다. 메인 차트를 깔끔하게 유지하기 위해 현재 축 제목이나 레이블이 없습니다. 예를 들어 데이터가 어떤 연도를 다루는지 바로 알 수 없습니다. 이것을 모든 차트에 추가할 필요는 없지만 범례에는 주석으로 달아야 합니다. @sec-lemurs 에서 논의한 것처럼 색상에만 의존하지 않도록 차트의 접근성을 높이기 위해 차트의 *민주당(Democratic Party)* 및 *공화당(Republican Party)* 영역을 식별하는 직접 레이블도 추가할 것입니다.

단일 주만 선택하도록 데이터를 필터링하는 것으로 시작하겠습니다. 어느 주를 선택하든 상관없지만 차트에 정당 레이블을 직접 추가할 수 있도록 충분한 공간이 있는 주가 이상적입니다. 여기서는 범례 플롯으로 캘리포니아(`"CA"`)를 사용합니다. \index{dplyr!filter}

```{r}
#| label: elections-legend-data
ca_data <- filter(plot_data, state_po == "CA")
```

그런 다음 메인 플롯을 위해 작성된 코드를 재사용하여 `ca_data`를 `ggplot()` 함수에 전달한 다음 미적 매핑과 `geom_area()`로 영역 차트를 추가합니다. 색상과 사용자 정의 주(패싯) 레이블은 이 장의 앞부분에서 설명한 대로 `scale_fill_manual()` 및 `geom_text()`로 추가됩니다. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_area} \index{ggplot2!geom\_text} \index{ggplot2!scale\_fill\_manual}

```{r}
#| label: elections-ca-plot
ca_plot <- ggplot(data = ca_data) +
  geom_area(
    mapping = aes(
      x = year,
      y = votes,
      fill = party
    ),
    position = "fill"
  ) +
  # label for state
  geom_text(
    mapping = aes(
      x = mean(range(year)),
      y = 0.5,
      label = state_po
    ),
    family = title_font,
    color = alpha(bg_col, 0.3),
    size = 4
  ) +
  # colors
  scale_fill_manual(
    values = c(
      "민주당" = blue_col,
      "공화당" = red_col,
      "기타" = other_col
    ),
    guide = "none"
  )
```

그런 다음 `annotate()` 함수를 사용하여 다음을 추가합니다: \index{ggplot2!annotate} \index{annotations}

* 데이터의 시작 연도와 끝 연도에 대한 두 개의 레이블. 이것들을 플롯의 경계 내에 유지하기 위해 시작 레이블은 왼쪽 정렬하고 끝 레이블은 오른쪽 정렬합니다.

* *공화당*과 *민주당*에 대한 두 개의 레이블. *기타* 범주는 매우 작고 남은 유일한 범주임이 분명하므로 레이블을 지정하지 않은 상태로 둡니다.

메인 플롯에서와 같이 `coord_cartesian()` 내부에 `expand = FALSE`를 설정하여 가장자리 주변의 추가 공간을 제거합니다. 또한 주석이 필요한 모든 정보를 전달하므로 `theme_void()`를 사용하여 추가 차트 요소를 제거합니다. \index{ggplot2!coord\_cartesian} \index{ggplot2!theme\_void}

```{r}
#| label: fig-elections-inset-plot
#| fig-cap: "캘리포니아 패싯의 확대 버전으로 구성된 사용자 정의 범례 플롯으로, 기간과 색상으로 표시된 범주를 나타내는 추가 주석이 있습니다."
#| fig-alt: "캘리포니아 패싯의 확대 버전으로 구성된 사용자 정의 범례 플롯으로, 기간과 색상으로 표시된 범주를 나타내는 추가 주석이 있습니다."
#| fig-asp: 1
#| fig-width: 3
#| fig-align: center
p_inset <- ca_plot +
  # year labels
  annotate(
    geom = "text",
    x = min(ca_data$year),
    y = 0.05,
    label = min(ca_data$year),
    family = korean_font,
    color = bg_col,
    size = 3,
    hjust = 0
  ) +
  annotate(
    geom = "text",
    x = max(ca_data$year),
    y = 0.05,
    label = max(ca_data$year),
    family = korean_font,
    color = bg_col,
    size = 3,
    hjust = 1
  ) +
  # Party labels
  annotate(
    geom = "text",
    x = mean(range(ca_data$year)),
    y = 0.8,
    label = "민주당",
    family = korean_font,
    color = bg_col,
    size = 3.5
  ) +
  annotate(
    geom = "text",
    x = mean(range(ca_data$year)),
    y = 0.2,
    label = "공화당",
    family = korean_font,
    color = bg_col,
    size = 3.5
  ) +
  coord_cartesian(expand = FALSE) +
  theme_void()
p_inset
```

이제 사용자 정의 범례를 @fig-elections-plot-style-2 에 추가할 준비가 되었습니다.

### **`patchwork`**로 결합하기

이제 마지막 단계는 사용자 정의 범례를 메인 플롯과 결합하는 것입니다. 이미 메인 플롯에 범례가 들어갈 빈 공간을 남겨 두었으므로 @sec-time-zones 에서 했던 것처럼 **`patchwork`** [@patchwork]의 `inset_element()` 함수를 사용합니다. `left`, `right`, `top`, `bottom` 인수를 사용하여 메인 플롯과 관련하여 범례의 모서리가 나타날 위치를 선택합니다. 이 값을 올바르게 얻으려면 약간의 시행착오가 필요합니다! `align_to = "full"`을 설정하면 기본 설정에 따른 패널 영역만이 아니라 전체 차트 영역을 기준으로 좌표를 선택할 수 있습니다. \index{patchwork} \index{patchwork!inset\_element}

```{r}
#| label: fig-combine-plots
#| fig-cap: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 캘리포니아의 영역 차트 확대 버전이 왼쪽의 범례로 사용됩니다."
#| fig-alt: "미국 모양의 그리드에 배열된 패싯 영역 차트로, 시간 경과에 따른 정당별 득표율을 보여줍니다. 캘리포니아의 영역 차트 확대 버전이 왼쪽의 범례로 사용됩니다."
#| warning: false
final_plot <- styled_plot_2 + inset_element(
  p = p_inset,
  left = 0.035,
  bottom = 0.087,
  right = 0.295,
  top = 0.55,
  align_to = "full"
)
final_plot
```

그런 다음 `ggsave()`로 파일에 저장할 수 있습니다! \index{ggplot2!ggsave}

```{r}
#| label: elections-save
#| eval: false
#| echo: true
ggsave(
  filename = "us-elections.png",
  plot = final_plot,
  width = 5,
  height = 0.5 * 5
)
```

## 회고

이 시각화는 방대한 양의 복잡한 정보를 꽤 직관적인 방식으로 요약합니다. 색상은 인식 가능한 정당 색상과 일치하고, 그리드는 즉시 인식 가능한 모양으로 배열되며, 영역 차트는 시간 경과에 따른 득표율을 명확하게 나타냅니다. 그러나 몇 가지 더 개선할 수 있는 부분과 고려해야 할 다른 요소가 있습니다.

주 두 글자 약어를 사용하면 공간을 절약하고 과도한 텍스트를 피할 수 있지만 독자가 특히 미국 지리에 익숙하지 않은 경우 관심 있는 주를 쉽게 찾기가 더 어렵습니다. 약어 아래에 작은 텍스트를 추가하거나 마우스를 갖다 대면 주 이름을 제공하는 대화형 버전을 만들면 더 쉬울 것입니다.

::: {#tip-elections-interactive .callout-tip}

## {ggplot2}를 이용한 인터랙티브 차트

이 책은 정적 시각화를 만드는 데 중점을 두지만 웹 기반 결과물에 사용할 대화형 차트를 개발하는 데에도 관심이 있을 수 있습니다. R에는 대화형 시각화를 만들 수 있는 많은 패키지가 있으며 **`ggplot2`** 사용자에게 특히 유용한 몇 가지 패키지가 있습니다: \index{plotly} \index{plotly!ggplotly} \index{ggiraph}

* **`plotly`** [@plotly]: `plotly.js` 자바스크립트 라이브러리를 사용하여 대화형 그래픽을 구축할 수 있습니다. `ggplotly()` 함수는 **`ggplot2`** 플롯을 **`plotly`** 플롯으로 변환하여 대화형 그래픽을 만드는 빠른 방법입니다.

* **`ggiraph`** [@ggiraph]: **`ggplot2`** 그래픽에 툴팁, 확대/축소 및 클릭 가능한 요소를 추가할 수 있습니다.

:::

색상은 직관적이지만 강도가 비슷하기 때문에 가장 접근하기 쉬운 것은 아닙니다. @sec-longbeach 에서 했던 것처럼 **`colorblindr`**의 `cvd_grid()` 함수를 사용한다면 이 색상들이 훨씬 덜 구별되어 보일 수 있습니다. 밝은 파란색과 밝은 빨간색의 조합을 선택하거나 밝은 빨간색과 밝은 파란색의 조합을 선택하면 색상의 직관성은 유지되지만 접근성은 향상될 것입니다. \index{color} \index{accessibility} \index{colorblindr!cvd\_grid}

득표율은 본질적으로 선거를 결정하는 것이므로 백분율을 표시하기 위해 영역 차트를 사용하는 것은 직관적이고 합리적입니다. 그러나 득표 수의 합계를 보는 것도 흥미로울 것입니다. 특히 주는 인구가 매우 다를 수 있기 때문입니다. 인구가 많은 주에서 백분율이 조금만 변경되어도 득표 수가 크게 변할 수 있지만, 이 시각화 버전에서는 이를 볼 수 없습니다.

::: {.content-visible when-format="html"}

이 시각화의 원본 버전을 개발하는 과정에서 생성된 각 플롯은 **`camcorder`**를 사용하여 캡처되었으며 아래 gif에 표시됩니다. 데이터 시각화 프로세스에서 **`camcorder`**를 사용하는 방법에 대해 자세히 알아보려면 @sec-camcorder 를 참조하십시오.

![](images/elections.gif){fig-align="center" fig-alt="차트 작성 과정의 Gif"}

:::

## 연습 문제

* 사용자 정의 범례 플롯으로 캘리포니아를 사용하는 대신 모든 주의 *전체* 투표율을 보여주는 플롯을 만드십시오. 차트를 해석하는 방법을 설명하기 위해 텍스트를 업데이트해야 합니까?

* 득표율 대신 총 투표 수를 표시하도록 시각화를 편집하십시오. 비슷한 패턴이 보입니까? 자동화된 방식으로 주에 대한 패싯 레이블 위치를 어떻게 선택할 수 있습니까?
