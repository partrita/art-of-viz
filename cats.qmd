---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-asp: 0.75
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/source_caption.R
```

# 고양이: **`ggtext`**를 사용한 데이터 기반 주석 {#sec-cats}

이 장에서는 소셜 미디어 아이콘이 포함된 사용자 정의 캡션을 만들고 플롯에 데이터 기반 주석을 추가하는 방법을 배웁니다.

이 장을 마치면 다음을 할 수 있습니다:

* 핵심 **`ggplot2`** 함수를 사용하여 *버블 플롯*을 만듭니다;
* 흥미로운 데이터 포인트를 강조하기 위해 데이터 기반이면서도 미학적으로 즐거운 주석을 디자인합니다;
* 그래픽의 출처를 간결하게 표시하기 위해 캡션에 소셜 미디어 아이콘을 추가합니다.

이 장에 필요한 패키지를 로드하는 것으로 시작합니다.

```{r}
#| label: cats-pkgs-req
#| warning: false
#| message: false
library(dplyr)
library(ggplot2)
library(ggtext)
library(glue)
library(showtext)
library(stringr)
library(sysfonts)
library(tidyr)
library(tidytuesdayR)
```

이 장에서 사용하는 모든 패키지는 이전 장에서 이미 사용한 적이 있는 패키지들입니다. 하지만 그중 일부는 조금 더 깊이 있게 다루고 일부는 새로운 함수를 사용할 것입니다!

## 데이터

2013년과 2017년 사이에 @kays2020 은 미국, 영국, 호주, 뉴질랜드에서 자신의 반려묘에게 GPS 센서를 부착할 지원자를 모집했습니다. 이 데이터[@cats_data]는 반려묘가 새와 같은 토착 종을 죽여 보존 문제를 일으키기 때문에 수집되었습니다. 다른 고양이들이 집에 없을 때 어떻게 움직이는지 연구하면 반려묘가 환경에 미치는 영향을 이해하는 데 도움이 될 수 있습니다. 이 장에서는 영국에 기반을 둔 고양이(및 그 주인!)의 데이터에 초점을 맞출 것입니다.

이 데이터는 2023년 1월([Tom Mock](https://github.com/jthomasmock)의 제안 이후) TidyTuesday 데이터 세트로 사용되었으므로 **`tidytuesdayR`** [@tidytuesdayR]의 `tt_load()` 함수로 로드할 수 있습니다. 두 개의 데이터 세트가 포함되어 있으며 `cats`와 `cats_reference`로 읽어옵니다. \index{tidytuesdayR!tt\_load}

```{r}
#| label: cats-data-show
#| eval: false
#| echo: true
tuesdata <- tt_load("2023-01-31")
cats <- tuesdata$cats_uk
cats_reference <- tuesdata$cats_uk_reference
```

```{r}
#| label: cats-data-hide
#| output: false
#| echo: false
#| eval: true
cats <- readr::read_csv("data/cats_uk.csv")
cats_reference <- readr::read_csv("data/cats_uk_reference.csv")
```

`cats` 데이터에는 타임스탬프별로 기록된 위도 및 경도를 포함한 센서 정보가 들어 있습니다. 각 고양이에 대해 여러(많은) 관측치가 있어 `r ncol(cats)`개 열에 걸쳐 총 `r nrow(cats)`개의 행이 됩니다. 일부 관측치는 자동 알고리즘, 수동 또는 둘 다에 의해 이상치로 표시되었습니다. `cats_reference` 데이터에는 이름, 나이, 성별, 실내에서 보내는 시간, 먹는 음식 유형 등 고양이 주인이 제공한 각 개별 고양이에 대한 정보가 들어 있습니다. 두 데이터 세트는 `cats`와 `cats_reference` 모두에 존재하는 `tag_id` 열로 결합할 수 있습니다.

## 탐색 작업

`cats` 데이터를 사용하여 공간 패턴에 초점을 맞추고 고양이가 이동하는 범위를 살펴볼 수 있습니다. 예를 들어, 평균적인 고양이는 하루에 얼마나 이동할까요? 또는 `cats_reference` 데이터에 초점을 맞추고 고양이의 다양한 행동과 특성 간의 관계를 살펴볼 수 있습니다. 예를 들어, 나이 든 고양이는 실내에서 더 많은 시간을 보낼까요? 아니면 다른 고양이와 함께 사는 고양이가 집에 더 많은 먹이를 가져올까요?

세 번째 옵션이자 아마도 가장 유용한 옵션은 두 데이터 세트를 결합하는 것입니다. 개체를 지리적 데이터에 결합하면 다음과 같은 질문에 답할 수 있을 것입니다: 수컷 고양이는 하루에 더 멀리 이동할까요? 나이 든 고양이는 집 근처에 머물까요? *선물*을 많이 가져오는 고양이의 전략은 무엇일까요?

### 데이터 탐색

지리적 `cats` 데이터를 파헤치는 것으로 시작해 보겠습니다. `plot()`을 사용하여 좌표 데이터의 매우 빠른 플롯을 만들 수 있습니다. \index{graphics!plot}

```{r, echo=-1}
#| label: fig-cats-map
#| fig-cap: "반려묘에게 부착된 GPS 데이터에서 얻은 지리적 좌표를 보여주는 산점도. 배경 지도가 없어 맥락 없이는 해석하기 어렵지만, 일부 클러스터를 볼 수 있습니다."
#| fig-alt: "반려묘에게 부착된 GPS 데이터에서 얻은 지리적 좌표를 보여주는 산점도. 배경 지도가 없어 맥락 없이는 해석하기 어렵지만, 일부 클러스터를 볼 수 있습니다."
par(mar = c(5.1, 4.1, 2.1, 2.1))
plot(
  x = cats$location_long,
  y = cats$location_lat,
  xlab = "Longitude",
  ylab = "Latitude"
)
```

@fig-cats-map 의 데이터가 지리적 좌표 데이터임을 감안할 때, 위치와 거리에 대한 더 많은 맥락을 제공하는 배경 지도가 있다면 좀 더 잘 이해할 수 있을 것입니다. 하지만 이 매우 최소한의 지도로도 많은 작은 점 클러스터가 있음이 분명합니다. 어쩌면 각 클러스터가 특정 고양이일 수도 있겠죠?

::: {#tip-cats-lat-long .callout-tip}

## 위도와 경도 기억하기

지도에 아무리 많이 그려봐도 x축과 y축 중 어느 것이 위도이고 경도인지 기억하는 것은 결코 쉬워 보이지 않습니다! 기억하는 한 가지 방법은 다음과 같습니다:

* 세계 지도를 상상해 보세요. 아마도 직사각형이고 *긴(long)* 가장자리가 바닥을 따라갈 것입니다.
* *경도(longitude)*는 바닥, 즉 x축을 따라갑니다.

:::

GPS 센서는 고양이의 지상 속도에 대한 데이터도 보고하므로 하루 동안의 활동 수준 패턴을 볼 수 있을 가능성이 있습니다. `hist()`를 사용하여 탐색적 히스토그램을 그려 `ground_speed` 열을 살펴봅시다: \index{graphics!hist}

```{r, echo=-1}
#| label: fig-cats-speed-hist
#| fig-cap: "GPS 센서에서 기록된 지상 속도의 히스토그램으로, 매우 높은 속도를 포함하여 매우 치우친 분포를 보여줍니다!"
#| fig-alt: "GPS 센서에서 기록된 지상 속도의 히스토그램으로, 매우 높은 속도를 포함하여 매우 치우친 분포를 보여줍니다! x축은 초당 250000미터까지 올라갑니다."
par(mar = c(5.1, 4.1, 3.1, 2.1))
hist(
  x = cats$ground_speed,
  xlab = "Ground speed (m/s)",
  main = "Histogram of ground speed"
)
```

언뜻 보기에 @fig-cats-speed-hist 에서 특별히 주목할 만한 것을 보지 못할 수도 있습니다. 그러나 데이터 설명에 따르면 지상 속도는 초당 미터(m/s)로 측정되지만 히스토그램은 250,000까지 올라갑니다. m/s 단위를 자주 사용하지 않는 분들을 위해 설명하자면, 이는 시속 약 560,000마일 또는 시속 900,000킬로미터에 해당합니다! 이 고양이들이 유난히 빠르거나 지상 속도 데이터에 문제가 있는 것입니다. 아마도 단위가 잘못 기록되었거나 센서가 올바르게 작동하지 않았을 수 있습니다. 정확한 문제는 알 수 없지만, 이 열은 확실히 우리가 너무 신뢰해서는 안 되는 데이터 열입니다.

대신 `cats_reference` 데이터에 초점을 맞추고 연구 대상 고양이들의 특성이 어떻게 다른지 살펴봅시다. 예를 들어, 범주형 변수 `hrs_indoors`로 기록된 고양이가 실내에서 보내는 시간을 살펴볼 수 있습니다. `table()`을 사용하여 각 실내 시간 *범주*에 속하는 고양이가 몇 마리인지 계산한 다음 `barplot()`을 사용하여 시각화할 수 있습니다: \index{graphics!barplot} \index{base!table}

```{r, echo=-1}
#| label: fig-cats-bar-hrs
#| fig-cap: "실내에서 보내는 평균 시간의 5가지 범주 각각에 속하는 고양이 수를 보여주는 막대 차트. 데이터가 처음에는 숫자로 보일 수 있지만 실제로는 범주형 데이터입니다."
#| fig-alt: "실내에서 보내는 평균 시간의 5가지 범주 각각에 속하는 고양이 수를 보여주는 막대 차트. 데이터가 처음에는 숫자로 보일 수 있지만 실제로는 범주형 데이터입니다. 분포는 종 모양 곡선을 따릅니다."
par(mar = c(4.1, 4.1, 3.1, 2.1))
barplot(table(cats_reference$hrs_indoors))
```

건강 문제나 에너지 수준으로 인해 나이 든 고양이가 실내에서 더 많은 시간을 보내므로 고양이가 실내에서 보내는 시간이 연령에 따라 다를 것이라고 예상할 수 있습니다. `plot()`을 사용하여 `age_years` 대 `hrs_indoors`의 빠른 산점도를 만들어 조사해 봅시다: \index{graphics!plot}

```{r, echo=-1}
#| label: fig-cats-scatter
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 산점도."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 산점도. 플롯에 표시된 고양이보다 데이터 포인트가 적은 것 같습니다."
par(mar = c(5.1, 4.1, 2.1, 2.1))
plot(
  x = cats_reference$age_years,
  y = cats_reference$hrs_indoors,
  xlab = "Age",
  ylab = "Hours indoors"
)
```

@fig-cats-scatter 에는 약간의 패턴이 있지만 특별히 강한 것은 아닙니다. 이것은 자연적으로 연속적인 데이터를 그룹화할 때 정보를 잃기 때문에 `hrs_indoors` 열의 범주형 특성 때문일 수도 있습니다.

이러한 데이터 범주화는 또한 많은 점이 서로 겹쳐 쌓이는 결과를 초래합니다. 데이터에는 `r nrow(cats_reference)` 마리의 고양이가 있지만 @fig-cats-scatter 에는 `r nrow(cats_reference)` 개의 점이 있는 것처럼 보이지 않습니다. 시각화를 더 발전시킨다면 산점도에서 버블 플롯으로 변경하는 것을 고려할 수 있습니다. 버블 플롯을 사용하면 점의 크기는 각 `age_years`-`hrs_indoor` 범주 조합의 고양이 수와 같은 다른 변수와 관련됩니다.

### 탐색적 스케치

@fig-cats-scatter 의 아이디어를 가져와 텍스트와 주석을 특히 활용하여 훨씬 더 효과적인 시각화로 발전시켜 보겠습니다. 차트를 업데이트하여 버블 차트를 만들 것입니다. 하지만 가장 나이 많은 고양이나 실내에서 보내는 평균 시간과 같은 데이터의 흥미로운 측면을 강조하기 위해 주석도 추가할 것입니다. @fig-cats-sketch 는 우리가 어떻게 개발할 수 지에 대한 기본 그림을 제공합니다: \index{bubble chart}

![반려묘의 나이와 실내에서 보내는 시간 사이의 관계를 보여주는, 주석이 달린 버블 플롯의 초기 스케치.](images/sketch-cats.png){#fig-cats-sketch fig-align="center" fig-alt="반려묘의 나이와 실내에서 보내는 시간 사이의 관계를 보여주는, 주석이 달린 버블 플롯의 초기 스케치. 상자와 화살표는 특정 지점을 강조하는 캡션을 보여줍니다."}

## 플롯 준비

**`ggplot2`**에서 @fig-cats-sketch 를 만들기 위해서는 `cats_reference` 데이터의 두 열, 고양이 나이 `age_years`와 하루 평균 실내 체류 시간 `hrs_indoors`만 있으면 됩니다.

### 데이터 랭글링

`hrs_indoors` 열에는 실내 체류 시간에 대한 5가지 범주(`2.5`, `7.5`, `12.5`, `17.5`, `22.5`)가 포함되어 있습니다. 이러한 범주 이름은 숫자기 때문에 R에서는 범주가 아닌 숫자 열로 인코딩됩니다. 따라서 먼저 `hrs_indoors` 열을 `factor()`로 변환하는 것으로 시작합니다. 플롯의 *버블* 크기를 알기 위해서는 나이와 실내 체류 시간의 각 조합에 대해 고양이가 몇 마리인지 알아야 합니다. 두 관련 열을 `group_by()` 한 다음 **`dplyr`**의 `count()`를 사용하여 각 범주 조합의 수를 세고 `ungroup()`으로 그룹 해제합니다. \index{dplyr!select} \index{dplyr!mutate} \index{base!factor} \index{dplyr!group\_by} \index{dplyr!count} \index{dplyr!ungroup} 

나이를 알 수 없는 고양이 한 마리(`r cats_reference$animal_id[is.na(cats_reference$age_years)]`)가 있으므로 **`tidyr`**의 `drop_na()`를 사용하여 이 값을 제거합니다. 데이터의 누락된 값을 시각화하고 처리하는 방법에 대한 다른 논의는 @sec-bees 및 @sec-r-pkgs 를 참조하십시오. \index{tidyr!drop\_na}

```{r}
#| label: cats-wrangling
plot_data <- cats_reference |>
  select(age_years, hrs_indoors) |>
  mutate(hrs_indoors = factor(hrs_indoors)) |>
  group_by(age_years, hrs_indoors) |>
  count() |>
  ungroup() |>
  drop_na()
```

### 첫 번째 플롯

평소와 같이 데이터를 `ggplot()` 함수에 전달한 다음 `aes()`로 미학적 매핑을 설정합니다. @fig-cats-scatter 에서 했던 것처럼 나이를 x축에, 실내 시간을 y축에 둡니다. 여기서는 각 범주 조합의 고양이 수 `n`을 `size` 미학에 매핑하여 버블을 만듭니다. 산점도보다는 버블 플롯을 만들고 있지만, 두 유형의 플롯 모두 점으로 만들어지므로 `geom_point()`를 사용합니다. 산점도는 기본적으로 모든 점이 하나의 관측치를 나타내므로 모두 같은 크기인 버블 플롯의 특수한 경우입니다. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_point}

```{r}
#| label: fig-cats-base-plot
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 원의 크기는 각 범주의 고양이 수를 나타냅니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 원의 크기는 각 범주의 고양이 수를 나타냅니다. 범례 값은 2.5, 5, 7.5입니다."
basic_plot <- ggplot(
  data = plot_data,
  mapping = aes(
    x = age_years,
    y = hrs_indoors,
    size = n
  )
) +
  geom_point()
basic_plot
```

## 고급 스타일링

이제 플롯 스타일링을 시작하여 일반적인 기본 버블 플롯에서 R로 만든 것 같지 않은 플롯으로 바꿀 준비가 되었습니다!

### 색상

데이터의 어떤 열도 `color`나 `fill`에 매핑하지 않으므로 색상 팔레트를 지정할 필요가 없습니다. 대신 텍스트 색상(진한 회색), 배경 색상(흰색), 강조 색상(보라색)을 선택합니다. \index{color}

```{r}
#| label: cats-colors
text_col <- "#2F4F4F"
highlight_col <- "#914D76"
bg_col <- "white"
```

초기 `basic_plot` 코드를 업데이트하여 `geom_point()` 내부에서 점의 색상을 `highlight_col`로 변경할 수 있습니다. 이 색상은 데이터의 열을 기반으로 하지 않으므로 `aes()` 안에 들어갈 필요가 없다는 것을 기억하십시오. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_point}

`size` 범례는 자동으로 생성되며 데이터 범위를 고려하여 균등하게 간격을 둔 간격을 선택합니다. 불행히도 이로 인해 의미가 통하지 않는 레이블이 생성되는 경우가 있습니다. 여기서는 2.5마리의 고양이에 대한 레이블이 있는데, 자연계에는 존재하지 않는 것입니다! `size` 범례에 더 적절한 중단점을 선택해 봅시다. 여기서 `size` 데이터 범위는 `r min(plot_data$n)`에서 `r max(plot_data$n)` 사이이므로 `3`, `6`, `9`로 가봅시다. 원하는 중단점을 벡터로 전달하여 `scale_size()`에 전달합니다. 플롯의 점 크기는 변경되지 않고 범례만 업데이트됩니다. \index{ggplot2!scale\_size}

```{r}
#| label: fig-cats-base-plot-2
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 보라색 원의 크기는 각 범주의 고양이 수를 나타냅니다. 크기 범례는 이제 정수로 표시됩니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 보라색 원의 크기는 각 범주의 고양이 수를 나타냅니다. 크기 범례는 이제 정수로 표시됩니다. 3, 6, 9입니다."
#| source-line-numbers: "9,10"
basic_plot <- ggplot(
  data = plot_data,
  mapping = aes(
    x = age_years,
    y = hrs_indoors,
    size = n
  )
) +
  geom_point(color = highlight_col) +
  scale_size(breaks = c(3, 6, 9))
basic_plot
```

### 텍스트 및 글꼴

여기서는 제목에 *재미있는* 서체를 사용하지만 나머지 텍스트에는 깔끔하고 미니멀한 서체를 사용하겠습니다. `body_font`에는 @sec-longbeach 에서 했던 것처럼 *Ubuntu*를 사용합니다. `title_font`에는 손글씨와 약간 비슷한 만화 같은 서체인 *Chewy*를 사용합니다. 둘 다 Google Fonts이므로 이전 장에서 했던 것처럼 `font_add_google()`을 사용하여 로드하고 관련 **`showtext`** 옵션을 설정합니다. \index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts} \index{fonts}

```{r}
#| label: cats-fonts
font_add_google(name = "Chewy")
font_add_google(name = "Ubuntu")
font_add_google(name = "Noto Sans KR", family = "noto_sans_kr")
showtext_auto()
showtext_opts(dpi = 300)
title_font <- "Chewy"
body_font <- "Ubuntu"
korean_font <- "noto_sans_kr"
```

### 주석 추가

차트는 *시각적* 요소로 간주됩니다. 그리고 *백문이 불여일견*이라는 말은 종종 데이터를 설명하는 대신 시각화해야 하는 이유로 떠돌아다닙니다. 하지만 *그림*을 만든다고 해서 단어를 사용할 수 없는 것은 아닙니다. 텍스트 표시기를 추가하여 명확성을 높인다면 차트의 약점이 아닙니다.

@sec-programming 에서 부제목을 구성할 때 `glue()`를 사용하여 데이터 기반 텍스트를 만들었습니다. 즉, 기본 데이터가 업데이트되면 부제목도 올바르게 업데이트됩니다. 모든 텍스트를 *하드 코딩*하는 것보다 우발적인 오류가 발생할 가능성이 적은 더 효율적인 접근 방식입니다. 플롯에 주석을 추가할 때도 비슷한 접근 방식을 취할 수 있습니다.

데이터에서 가장 나이 많은 고양이를 강조하는 주석을 플롯에 추가하고 싶다고 가정해 보겠습니다. 가장 나이 많은 고양이와 관련된 데이터를 얻는 것으로 시작하겠습니다. **`dplyr`**의 `slice_max()`를 사용하여 `age_years`가 가장 높은 데이터 행을 얻을 수 있습니다: \index{ggplot2!slice\_max}

```{r}
#| label: cats-oldest
annot_oldest <- cats_reference |>
  slice_max(age_years)
```

플롯에 주석을 추가할 때 **`ggplot2`** 내에서 몇 가지 선택을 할 수 있습니다:

* `text` 또는 `label`: `text`를 사용하면 텍스트만 추가되는 반면 `label`은 직사각형 상자 안에 텍스트를 추가합니다.
* `annotate()` 또는 `geom_*()`: `annotate()`는 정해진 위치에 객체(이 경우 텍스트)를 배치하는 반면 `geom_*()` 함수는 일부 입력 데이터를 기반으로 객체를 추가합니다.

이러한 선택의 조합은 우리가 추가하려는 주석에 효과가 있을 것입니다. 그러나 우리는 **`ggplot2`** 대신 **`ggtext`** [@ggtext]를 사용할 것입니다. **`ggtext`** 패키지를 사용하면 레이블을 더 쉽게 사용자 정의할 수 있습니다. 이미 긴 문자열을 자동으로 래핑하기 위해 **`ggtext`**를 사용하는 예를 보았지만, 여기서는 텍스트의 특정 요소를 색상 지정하고 강조하는 것과 같은 다른 기능을 보여줄 것입니다. 이전에 **`marquee`** 패키지를 사용하여 @sec-turbines 에서 텍스트 섹션의 색상을 지정하는 것에 대해 설명했지만, 비교를 위해 **`ggtext`**를 살펴보겠습니다.

**`ggtext`**에서 `geom_textbox()` 함수를 사용하여 주석을 추가할 수 있습니다. 이전 장에서 부제목에 사용해 온 **`ggtext`**의 `element_textbox_simple()`과 마찬가지로 `geom_textbox()`는 텍스트를 미리 지정된 텍스트 상자 크기로 자동으로 래핑합니다. `label` 미학은 `glue()`를 사용하여 고양이의 이름과 나이를 텍스트에 넣습니다. 일부 `<span>` 태그 안에 텍스트 섹션을 래핑할 수 있습니다. 이렇게 하면 CSS를 사용하여 태그 내의 글꼴 스타일을 지정할 수 있습니다. 또한 `glue()`를 사용하여 고양이 이름에 사용된 글꼴의 `style`에 `highlight_col`을 삽입합니다. **`ggtext`** 대신 **`marquee`**를 사용하는 @sec-turbines 의 색상 텍스트 코드와 약간 겹치는 부분을 알아챌 수 있습니다. `geom_textbox()`의 추가 인수를 사용하면 텍스트, 상자 윤곽선 및 배경색의 색상은 물론 텍스트의 크기와 정렬을 제어할 수 있습니다. \index{ggplot2!aes} \index{ggtext!geom\_textbox} \index{glue!glue}

```{r}
#| label: fig-cats-annot-1
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 오른쪽 상단의 텍스트 상자는 'Boots'라는 가장 나이 많은 고양이를 나타냅니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 오른쪽 상단의 텍스트 상자는 'Boots'라는 가장 나이 많은 고양이를 나타냅니다."
annotated_plot <- basic_plot +
  geom_textbox(
    data = annot_oldest,
    mapping = aes(
      x = age_years - 2.5,
      y = factor(hrs_indoors),
      label = glue(
        "The oldest cat is <span style='color:{highlight_col}'>{animal_id}</span> who is {age_years} years old."
      )
    ),
    halign = 0.5,
    hjust = 0.5,
    size = 2.5,
    lineheight = 0.5,
    family = body_font,
    box.color = text_col,
    color = text_col,
    alpha = 0.5,
    maxheight = unit(4, "lines"),
    minwidth = unit(2, "lines"),
    maxwidth = unit(4, "lines")
  )
annotated_plot
```

`geom_textbox()` 함수 내에서 HTML 코드를 사용했지만 제목, 부제목 또는 캡션 텍스트에서도 HTML 코드를 사용할 수 있습니다. @sec-turbines 의 **`marquee`**와 마찬가지로 관련 `theme()` 인수를 편집하여 **`ggtext`**를 사용하고 있음을 지정해야 합니다.

::: {#tip-cats-repel .callout-tip}

## 겹치지 않는 레이블

여기서는 하나의 주석만 배치하므로 위치를 수동으로 조정하여 플롯 영역을 초과하거나 데이터 포인트를 가리지 않도록 하는 것이 비교적 쉽습니다. 텍스트 주석이 많은 경우 겹치지 않도록 수동으로 조정하기가 금세 어려워질 것입니다. **`ggrepel`** 패키지 [@ggrepel]가 도움이 될 수 있습니다. **`ggplot2`**에서 겹치지 않는 텍스트 및 레이블 주석을 만드는 데 특별히 설계되었으며 텍스트를 재배치합니다.

:::

주석이 플롯의 어떤 측면을 가리키는지 명확히 하기 위해 텍스트 상자에서 관련 데이터 포인트로 향하는 화살표를 추가할 수 있습니다. 화살표 하나만 추가하므로 `annotate()` 함수를 사용합니다. `annotate()`를 사용할 때 어떤 유형의 *geom*을 사용할지 지정해야 합니다. 화살표를 추가하려고 하지만 실제로는 geom이 아닙니다. 선을 추가한 다음 선의 끝을 화살표로 장식해야 합니다. 직선 화살표를 추가하려면 `geom = "segment"`를 설정할 수 있지만 곡선 화살표가 덜 딱딱해 보이는 경우가 많으므로 `geom = "curve"`를 사용합니다. \index{ggplot2!annotate}

화살표를 어디에 놓을지 `annotate()`에 알려주어야 합니다. 이 좌표 선택이 처음부터 완벽했다고 생각하지 마십시오! 화살표를 원하는 위치에 배치하려면 적어도 약간의 시행착오가 필요합니다. @fig-cats-annot-1 의 x축을 사용하여 `x` 및 `xend` 값이 무엇이어야 하는지 선택하는 데 가이드로 사용할 수 있습니다. `y` 및 `yend` 값의 선택은 조금 이상해 보일 수 있습니다. y축이 화살표를 22 정도에 배치하고 싶다고 제안하는데 왜 5 정도에 화살표를 배치할까요? `hrs_indoors`는 실제로 숫자 열이 아니라 팩터 열이라는 것을 기억하십시오. \index{ggplot2!annotate}

::: {#tip-cats-pos-annot .callout-tip}

## 주석 위치 지정

**`ggplot2`**를 사용하여 주석 위치를 *딱 맞게* 지정하려고 할 때 왼쪽으로 약간, 오른쪽으로 약간, 위로 조금, 그런 다음 오른쪽으로 조금 더 등을 하면서 많은 시간을 보내기 쉽습니다.

**`ggannotate`** 패키지 [@ggannotate]는 당신의 삶을 조금 더 쉽게 만들어 줄 것입니다. 주석을 원하는 곳에 정확히 배치하는 데 도움이 되는 포인트 앤 클릭 도구입니다! \index{ggannotate}

:::

이산형 척도에서 숫자 값을 사용하여 화살표를 배치하려고 할 때 **`ggplot2`**가 불평할 것이라고 예상할 수 있지만 놀랍게도 그렇지 않습니다. 팩터는 기본적으로 정렬된 범주이므로 R은 팩터의 첫 번째 수준을 `1`로, 두 번째 수준을 `2`로 할당합니다. 즉, 팩터를 숫자 변수로 변환할 수 *있습니다*. 결과가 항상 예상한 것과 같지 않을 수 있다는 점에 유의하십시오! 차트의 경우 화살표의 끝을 다섯 번째 범주인 `22.5` 값 바로 아래에 배치하고 싶으므로 `y` 및 `yend` 값은 `5`보다 약간 아래입니다.

너비, 색상 및 선의 곡률을 지정하여 선에 몇 가지 추가 스타일을 추가합니다. 선 끝에 화살표를 추가하기 위해 `arrow()` 함수를 사용합니다. 이 함수를 사용하면 화살표의 전체 길이가 아닌 화살촉의 길이를 정의할 수 있습니다. 또한 유형이 `"closed"`라고 지정하여 화살촉이 채워진 삼각형임을 의미합니다. 기본값은 `"open"`이며 화살표 크기가 작을 때 덜 명확해 보이는 경우가 있습니다. \index{grid!arrow}

```{r}
#| label: fig-cats-arrow
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 오른쪽 상단의 텍스트 상자는 'Boots'라는 가장 나이 많은 고양이를 나타내며, 이 고양이에 대한 데이터 포인트를 가리키는 화살표가 있습니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 오른쪽 상단의 텍스트 상자는 'Boots'라는 가장 나이 많은 고양이를 나타내며, 이 고양이에 대한 데이터 포인트를 가리키는 화살표가 있습니다."
arrow_plot <- annotated_plot +
  annotate(
    geom = "curve",
    x = 15.1,
    xend = 16,
    y = 4.6,
    yend = 4.9,
    linewidth = 0.3,
    color = text_col,
    curvature = 0.5,
    arrow = arrow(
      length = unit(1.5, "mm"), type = "closed"
    )
  )
arrow_plot
```

::: {#tip-cats-highlight .callout-tip}

## 데이터의 관측치 강조 표시

@sec-museums 에서는 **`gghighlight`** [@gghighlight]를 사용하여 패면 플롯의 개별 선을 강조 표시했습니다. **`gghighlight`**를 사용하여 보다 자동화된 방식으로 개별 데이터 포인트를 강조 표시하고 레이블을 지정할 수도 있습니다. 더 사용자 정의되고 미학적으로 즐거운 주석을 희생하더라도 일부 조건에 따라 여러 지점을 강조 표시하려는 경우 더 쉬운 접근 방식이 될 수 있습니다.

:::

### 텍스트 추가

차트에 다른 더 표준적인 텍스트를 추가하고 제목과 부제목 텍스트를 저장할 변수를 정의해 보겠습니다. 부제목의 경우 다시 `glue()`를 사용하여 @sec-programming 에서 했던 것처럼 미리 계산된 값을 데이터에서 텍스트로 붙여넣어 데이터 기반 접근 방식을 취합니다. \index{glue!glue}

```{r}
#| label: cats-text-1
# title text
title <- "Do older cats spend more time indoors?"
# subtitle text
perc_indoor <- round(100 * sum(cats_reference$hrs_indoors == "22.5") / nrow(cats_reference))
st <- glue("Around {perc_indoor}% of cats in the study spend on average 22.5 hours per day indoors! There is a slight trend for cats to spend more time indoors as they age.")
```

### 사용자 정의 캡션 함수

@sec-turbines 에서 `source_caption()` 함수를 구성할 때 차트 작성자의 이름(예: `"N. Rennie"`)을 나타내는 문자열만 전달했습니다. 더 유용한 방법은 차트 작성자에게 연락하거나 더 잘 식별할 수 있는 방법입니다. 이렇게 하면 독자가 원하는 경우 데이터나 코드를 파헤칠 수 있고 차트 작성자가 자신의 작업에 대한 다른 예시로 더 쉽게 연결할 수 있습니다. 예를 들어 웹사이트에서 소셜 미디어 프로필로 연결하는 것은 매우 일반적입니다. 정적 차트[@social_icons]에 대해서도 매우 유사한 작업을 수행할 수 있습니다.

단순히 이름이 있는 문자열을 전달하는 대신 소셜 미디어 아이콘과 관련 핸들이 포함된 캡션을 만들 것입니다. 이것은 여러 다른 플롯(그리고 아마도 다른 소셜 미디어 세부 정보가 있는 플롯)에 추가할 가능성이 높은 항목이므로 일부 사용자 입력을 기반으로 이 캡션을 생성하는 함수를 만들 것입니다.

하지만 먼저 함수 작성을 시작하기 전에 소셜 미디어 아이콘을 얻어야 합니다! @sec-turbines 에서 했던 것처럼 다시 [Font Awesome](https://fontawesome.com/) 아이콘 [@fontawesome]을 사용하지만 이번에는 *Solid* 아이콘 대신 *Brand* 팩 아이콘을 사용합니다. 여기서 아이콘을 로드하는 과정은 @sec-turbines 에서 Font Awesome 아이콘을 로드하는 것과 본질적으로 동일합니다. {{< monolink "https://fontawesome.com/download" "fontawesome.com/download" >}}에서 무료로 사용할 수 있는 아이콘의 zip 파일을 다운로드하고 **Free for Desktop** 옵션을 선택하면 `Font-Awesome-6-Brands-Regular-400.otf`라는 파일이 표시됩니다. 다시 말하지만, `fonts`라는 프로젝트 폴더와 같이 다시 찾을 수 있는 곳에 이 `.otf` 파일을 저장하십시오. \index{Font Awesome} \index{fonts}

이전과 마찬가지로 **`sysfonts`** [@sysfonts]의 `font_add()`를 사용하여 글꼴을 R로 로드합니다. `family` 인수는 R에서 글꼴을 참조하는 방법이고 `regular` 인수는 `.otf` 파일의 파일 경로입니다. 그런 다음 `showtext_auto()` 및 `showtext_opts()`를 사용하여 **`showtext`**를 사용하여 텍스트를 렌더링하고 원하는 해상도를 설정합니다. \index{sysfonts!font\_add} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| echo: true
#| eval: true
#| file: R/load_font_awesome.R
```

::: {#tip-cats-fa-icons .callout-tip}

## R의 Font Awesome 아이콘

**`fontawesome`** 패키지 [@fontawesomeR]를 사용하면 R로 만든 R Markdown, Quarto 및 Shiny 출력에서 Font Awesome 아이콘을 더 쉽게 사용할 수 있습니다. 패키지를 사용하면 아이콘을 SVG 또는 PNG 이미지로 삽입할 수 있으며 Shiny 애플리케이션에서 `<i></i>` 태그를 사용하여 아이콘을 삽입하는 HTML 코드를 작성하는 기능을 제공합니다.

:::

이제 소셜 미디어 아이콘 추가로 돌아가서 우리를 위해 캡션을 작성할 `social_caption()` 함수를 만들어 보겠습니다. 어떤 옵션을 사용자가 지정해야 하는지 생각하는 것부터 시작합니다:

* 포함할 소셜 미디어 아이콘과 핸들의 선택. 사용자가 특정 소셜 미디어 아이콘과 함께 사용되는 핸들을 업데이트할 수 있기를 원합니다(예: 업무용 계정과 개인용 계정 간 전환).
* 또한 사용자가 원할 경우 특정 소셜 미디어 아이콘을 *끄는* 옵션도 제공해야 합니다.
* 아이콘과 글꼴의 색상. 이들을 동일하게 강제하거나 다르게 허용할 수 있습니다.
* 비 아이콘 텍스트, 즉 소셜 미디어 핸들의 서체. 사용자가 차트의 나머지 텍스트와 일치하도록 서체 선택을 전달할 수 있기를 원합니다.

이 예제 `social_caption()` 함수를 구성하기 위해 LinkedIn, GitHub 및 BlueSky용 아이콘을 포함할 것입니다. 다른 아이콘을 포함하도록 선택할 수도 있습니다. 각 소셜 미디어 사이트에 대해 함수에 하나의 인수를 사용하며, 기본값은 가장 자주 사용될 핸들로 지정됩니다. 또한 아이콘과 글꼴 색상을 제어하기 위해 `icon_color`와 `font_color`라는 두 가지 인수를 추가합니다. 둘 다 기본적으로 `"black"`으로 설정되어 있으며 이는 다른 **`ggplot2`** 텍스트와 일치합니다.

함수 내에서 소셜 미디어 핸들에 대해 사용자가 입력한 값을 올바른 아이콘에 매핑하는 `data.frame`을 구성하는 것으로 시작합니다. **`ggtext`** [@ggtext]를 사용하여 캡션을 처리할 것입니다. 즉, HTML 코드를 작성하여 아이콘, 텍스트 및 텍스트 서식을 함께 결합할 수 있습니다. 또한 일부 HTML 코드에 전달할 수 있도록 각 소셜 미디어 아이콘에 매핑되는 유니코드 문자를 알아야 합니다.

GitHub 아이콘을 예로 들어 보겠습니다. {{< monolink "https://fontawesome.com/icons" "fontawesome.com/icons" >}}에서 원하는 아이콘을 검색하면 화면 오른쪽 상단에 유니코드 아이콘이 표시됩니다(Google 검색이나 ChatGPT도 똑같이 잘 작동할 것입니다!). GitHub 아이콘의 유니코드는 `f09b`이며 HTML 코드에서 이를 사용하려면 `&#xf09b`로 쓸 수 있습니다 [@social_icons]. 사용하려는 다른 아이콘에 대해서도 이 과정을 반복합니다.

그런 다음 `na.omit()`을 사용하여 `NA` 값이 포함된 `data.frame`의 행을 제거합니다. 각 소셜 미디어 핸들에 대한 기본 인수를 설정했으므로 기본적으로 `data.frame`에도 기본값이 없을 것입니다. 그러나 사용자가 캡션에서 특정 아이콘과 핸들을 제외하려는 경우 해당 인수 함수에서 `NA`로 설정하여 제외할 수 있습니다.

여러 아이콘과 핸들을 결합하는 함수를 즉시 작성하려고 하기보다는 하나의 아이콘과 하나의 소셜 미디어 핸들을 결합하는 함수를 작성하는 것으로 시작하겠습니다. 내부 함수인 `glue_icon()`은 `glue()`를 사용하여 아이콘 유니코드와 스니펫 내의 텍스트를 결합하여 스타일이 지정된 HTML 스니펫을 만듭니다. HTML 스니펫에는 두 개의 스팬이 포함되어 있습니다. 하나는 아이콘용( `"Font Awesome 6 Brands"` 글꼴과 선택한 `icon_color`로 스타일 지정)이고 다른 하나는 소셜 미디어 텍스트용(선택한 `font_family` 및 `font_color`로 스타일 지정)입니다. 또한 `&nbsp;`를 사용하여 아이콘과 핸들 사이에 공백을 추가하고, `&emsp;`를 사용하여 여러 아이콘을 구분하기 위해 끝에 더 큰 공백을 추가합니다. 이들은 HTML에 공백을 추가하기 위한 특수 문자열입니다. 따옴표 안에 따옴표, 그 안에 또 따옴표가 있으므로 `\"`를 사용하여 내부 따옴표를 이스케이프해야 합니다. \index{glue!glue}

마지막으로 **`purrr`** [@purrr]의 `map2()`를 사용하여 `icon_df` 데이터의 각 행에 `glue_icon()`을 적용합니다. 그런 다음 **`purrr`**의 `as_vector()`를 사용하여 결과 리스트를 벡터로 축소합니다. 그런 다음 **`stringr`**의 `str_flatten()`을 사용하여 벡터를 단일 문자열로 더 축소합니다. 이 병합된 문자열이 소셜 미디어 캡션입니다. \index{purrr!map2} \index{purrr!as\_vector} \index{stringr!str\_flatten} \index{social\_caption}

```{r}
#| echo: true
#| eval: true
#| file: R/social_caption.R
```

`source_caption()` 함수를 정의한 @sec-turbines 에서처럼 함수 정의 내에서 네임스페이싱을 사용하여 나중에 이 함수를 재사용하기 쉽게 만듭니다. 그런 다음 `social_caption()` 함수를 사용하여 이전에 정의한 색상 및 글꼴 변수를 관련 인수에 전달할 수 있습니다:

```{r}
#| label: cats-social
social <- social_caption(
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
social
```

`social_caption()`의 출력은 수동으로 입력하기 꽤 까다로웠을 이해하기 힘든 문자열임을 알 수 있습니다. 우리를 위해 이 함수를 만들어서 정말 다행입니다! 그런 다음 @sec-turbines 의 `source_caption()` 함수를 사용하고 `social_caption()` 함수의 출력을 `graphic` 인수에 전달할 수 있습니다. 또한 `<br>`을 사용하여 별도의 줄에 배치합니다. \index{source\_caption}

```{r}
#| label: cats-source-cap
cap <- source_caption(
  source = "McDonald JL, Cole H. 2020. doi.org/10.5441/001/1.pf315732.",
  sep = "<br>",
  graphic = social
)
```

그런 다음 변수를 `title`, `subtitle` 및 `caption` 인수에 전달하여 `labs()` 함수를 사용하여 평소와 같이 텍스트를 @fig-cats-arrow 에 추가할 수 있습니다. 또한 x축과 y축에 대한 제목에 더 유익한 텍스트를 추가하고 단위도 지정합니다. \index{ggplot2!labs}

::: {#tip-cats-branding .callout-tip}

## 개인 브랜딩 추가

*`ggbranding`* 패키지 [@ggbranding]를 사용하면 문자열을 직접 구성하지 않고도 플롯에 속성 표시를 위한 아이콘을 추가할 수 있습니다.

:::

기본적으로 범례 제목은 범례의 미학에 매핑된 열의 이름일 뿐입니다. 여기서 `size`에 매핑된 열은 `n`이며 범례 이름은 별로 유익하지 않습니다. 범례 이름을 편집하는 방법에는 여러 가지가 있습니다. 앞서 `scale_size()`를 사용할 때 `name` 인수를 지정할 수 있었습니다. 대안은 `labs()` 함수를 사용하는 것입니다. x`와 y`뿐만 아니라 모든 미학에 대한 제목을 `labs()`에서 지정할 수 있습니다. 원하는 범례 제목을 `size`에 전달하기만 하면 됩니다.

```{r}
#| label: fig-cats-text-plot
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 제목, 부제목 및 캡션이 추가되었지만 캡션은 올바른 형식이 아니라 원시 HTML 코드로 나타납니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 제목, 부제목 및 캡션이 추가되었지만 캡션은 올바른 형식이 아니라 원시 HTML 코드로 나타납니다."
text_plot <- arrow_plot +
  labs(
    title = title,
    subtitle = st,
    caption = cap,
    x = "Age of cat (years)",
    y = "Average time spent indoors (hours per day)",
    size = "Number of cats"
  )
text_plot
```

### 테마 조정

@fig-cats-text-plot 에서 우리가 열심히 만든 소셜 미디어 캡션이 제대로 포맷되지 않았고 단순히 우리가 작성한 원시 HTML 코드로 나타나는 것을 알 수 있습니다. 우리가 기대한 대로 보이지 않는 이유는 **`ggplot2`**가 기본적으로 HTML 코드를 파싱하는 방법을 이해하지 못하기 때문입니다. 바로 **`ggtext`**가 필요한 곳입니다. **`ggtext`**는 텍스트 요소 내에서 Markdown 및 HTML 사용에 대한 지원을 포함하여 **`ggplot2`**의 텍스트 렌더링을 개선하도록 설계되었습니다. 아직 캡션에 **`ggtext`**를 실제로 사용하지 않았습니다! @sec-turbines 의 **`marquee`**와 마찬가지로 `theme()`의 `plot.caption` 인수를 편집하여 HTML 코드를 처리하도록 **`ggtext`**를 사용하도록 지시해야 합니다. `element_textbox_simple()`을 사용하여 이 작업을 수행할 수 있습니다(어쨌든 부제목 텍스트를 래핑하기 위해 수행해 왔음). **`ggplot2`**의 `element_text()`와 유사한 인수를 가지고 있지만 여기서는 추가 인수를 지정할 필요가 없습니다. 매우 유사하게 작동하지만 기본값이 약간 다른 `element_textbox()`를 사용하거나 원한다면 `element_markdown()`을 사용할 수도 있습니다 [@social_icons]. \index{ggplot2!theme} \index{ggplot2!element\_text} \index{ggtext!element\_textbox\_simple}

이전 장에서 했던 것처럼 `theme_minimal()`을 기본 테마로 적용한 후 `theme()` 함수를 사용하여 몇 가지 추가 편집을 수행하여 플롯과 캡션 텍스트를 패널이 아닌 플롯에 정렬하고, 텍스트 색상을 변경하고, 배경색을 편집합니다. 또한 범례를 몇 가지 조정합니다. 현재 오른쪽 공간을 꽤 많이 차지하고 있지만 플롯 영역 자체 내에는 충분한 공간이 있습니다. `legend.position = "inside"`를 사용하여 범례를 패널 영역 내부로 이동하고 `legend.position.inside`를 사용하여 위치시키고 싶은 좌표를 지정합니다. 범례 위치 지정의 경우 `c(0, 0)`은 왼쪽 하단 모서리이고 `c(1, 1)`은 오른쪽 상단 모서리입니다. 범례와 데이터 포인트를 쉽게 구별할 수 있도록 주위에 어두운 윤곽선을 그립니다. \index{ggplot2!theme\_minimal} \index{ggplot2!element\_blank} \index{ggplot2!element\_rect}

```{r}
#| label: fig-cats-styled-plot
#| fig-cap: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 이제 텍스트가 모두 올바르게 포맷되었으며 범례는 플롯과 명확한 테두리가 있는 삽입 그림으로 나타납니다."
#| fig-alt: "반려묘의 나이와 실내에서 보내는 평균 시간 간의 관계를 보여주는 버블 플롯. 이제 텍스트가 모두 올바르게 포맷되었으며 범례는 플롯과 명확한 테두리가 있는 삽입 그림으로 나타납니다."
text_plot +
  theme_minimal(
    base_family = body_font,
    base_size = 6.5
  ) +
  theme(
    # legend styling
    legend.position = "inside",
    legend.position.inside = c(0.9, 0.25),
    legend.background = element_rect(
      fill = alpha(bg_col, 0.6),
      color = text_col
    ),
    # text
    text = element_text(color = text_col),
    plot.title = element_text(
      family = title_font,
      face = "bold",
      size = rel(1.5)
    ),
    plot.subtitle = element_textbox_simple(family = korean_font),
    plot.caption = element_textbox_simple(family = korean_font),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    # background and grid
    plot.margin = margin(5, 5, 5, 5),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = bg_col
    )
  )
```

마지막으로 `ggsave()`를 사용하여 차트를 PNG 형식으로 저장할 수 있습니다: \index{ggplot2!ggsave}

```{r}
#| label: cats-save
#| eval: false
#| echo: true
ggsave(
  filename = "cats.png",
  width = 5,
  height = 0.75 * 5
)
```

## 회고

이것은 매우 깔끔해 보이는 차트이며 주석이 추가되었지만 너무 복잡하거나 복잡해 보이지 않습니다. 아마도 가장 어린 고양이나 실내에서 가장 적은 시간을 보낸 고양이를 강조하기 위해 추가 주석을 (조심스럽게) 추가할 수 있습니다.

범례 상자와 주석 상자는 현재 꽤 다르게 보입니다. 범례 상자는 둥근 모서리에 비해 사각형 모서리를 가지고 있으며 윤곽선 색상이 더 어둡습니다. 일관성을 위해 두 상자가 동일한 스타일로 표시되면 더 보기에 좋을 것입니다.

이 차트에서는 두 가지 변수만 고려했지만 더 탐색할 수 있는 다른 많은 변수가 있습니다. GPS 데이터와 고양이 특성 데이터를 결합하는 것이 특히 유익할 것입니다. @fig-cats-styled-plot 에서는 고양이 나이와 고양이가 실내에서 보내는 시간 사이의 (약한) 관계만 전달합니다. 둘 다 고양이 주인이 보고합니다. 하지만 고양이가 실내에서 보내는 시간이 반드시 고양이의 활동 수준에 대해 많은 것을 말해주지는 않습니다. 집에 있을 때 하루 종일 잠을 잘까요? 실내에 없을 때는 뛰어다니나요, 아니면 단순히 햇볕을 쬐고 있나요? GPS 데이터를 결합했다면 아마도 나이와 활동 수준 간의 관계를 보여주는 더 유익한 플롯을 만들 수 있었을 것입니다.

::: {.content-visible when-format="html"}

이 시각화의 원본 버전을 개발하는 과정에서 생성된 각 플롯은 **`camcorder`**를 사용하여 캡처되었으며 아래 gif에 표시됩니다. **`camcorder`**를 데이터 시각화 프로세스에서 사용하는 방법에 대해 자세히 알아보려면 @sec-camcorder 를 참조하십시오.

원본 버전은 나이와 지상 속도 간의 관계를 살펴봅니다(데이터의 신뢰성 문제에도 불구하고).

![](images/cats.gif){fig-align="center" fig-alt="차트 작성 과정의 Gif"}

:::

## 연습 문제

* `tag_id` 열을 사용하여 `cats`와 `cats_reference` 데이터 세트를 결합하십시오. 두 데이터 세트를 결합하는 방법을 잘 모르는 경우 예제는 @sec-doctors 를 참조하십시오.

* 실내에서 보내는 시간을 y축에 그리는 대신 고양이의 평균 지상 속도를 플롯하십시오(값이 매우 비정상적이라는 것은 무시하십시오!).

* 평균 속도가 가장 높은 고양이를 강조하는 또 다른 주석을 추가하십시오.
