---
filters:
  - line-highlight
execute: 
  freeze: auto
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| warning: false
library(sysfonts)
```

```{r}
#| echo: false
#| eval: true
#| file: R/load_font_awesome.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/social_caption.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/source_caption.R
```

# 전 세계 의사 분포: **`ggplot2`**로 지도 만들기 {#sec-doctors}

이 장에서는 공개 데이터 소스를 식별하고, **`maps`** 패키지의 데이터를 사용하여 **`ggplot2`**로 지도를 만들고, 패싯(facet)을 독창적으로 사용하여 제목 패널을 만드는 방법을 배웁니다.

이 장을 마치면 다음을 할 수 있습니다:

* 핵심 **`ggplot2`** 패키지에 있는 함수만 사용하여 간단한 등치 지역도(choropleth map)를 만듭니다;
* 국가 경계 데이터를 얻고 공간 데이터에서 좌표계가 왜 중요한지 이해합니다;
* **`ggplot2`** 차트의 플롯 요소를 조작하여 플롯 제목에 색상 배경 영역을 만듭니다.

이 장에 필요한 패키지를 로드하는 것으로 시작합니다.

```{r}
#| label: doctors-pkgs-req
#| warning: false
#| message: false
library(dplyr)
library(ggplot2)
library(ggtext)
library(MetBrewer)
library(readr)
library(showtext)
library(sysfonts)
```

이 장에서는 @sec-turbines 에서 소개한 **`rcartocolor`**와 유사한 또 다른 색상 팔레트 패키지인 **`MetBrewer`**를 소개합니다. 또한 **`maps`** 패키지가 설치되어 있는지 확인해야 하지만, **`ggplot2`**를 통해 액세스할 것이므로 `library()`로 명시적으로 로드할 필요는 없습니다.

\index{maps} \index{MetBrewer}

## 데이터

Our World in Data 웹사이트({{< monolink "https://ourworldindata.org/" "ourworldindata.org" >}}) [@doctors_data]의 데이터 세트를 사용하여 *인구 1,000명당 의사 수*에 대한 데이터를 시각화할 것입니다. 웹사이트에 따르면 Our World in Data의 목표는 *세계의 가장 큰 문제에 대한 진전을 이루기 위한 연구와 데이터를 게시하는 것*입니다. 에너지와 환경에서 빈곤과 교육에 이르기까지 모든 것에 대한 데이터 세트가 있습니다. 그들의 웹사이트에는 영감을 찾고 있다면 아름답고 효과적인 데이터 시각화의 예가 많이 있습니다.\index{Our World in Data}

{{< monolink "https://ourworldindata.org/grapher/physicians-per-1000-people" "ourworldindata.org/grapher/physicians-per-1000-people" >}}에서 CSV 파일을 수동으로 다운로드하거나 @sec-turbines 에서 했던 것처럼 URL을 사용하여 R로 직접 다운로드할 수 있습니다. **`readr`**의 `read_csv()` 함수(또는 선호하는 경우 기본 R의 `read.csv()`)에 URL을 전달하기만 하면 됩니다. @sec-turbines 에서와 마찬가지로 나중에 다른 데이터 세트를 더 쉽게 로드할 수 있도록 URL을 기본 URL과 관심 있는 특정 페이지로 분리합니다. \index{readr!read\_csv} \index{utils!read.csv}

```{r}
#| label: doctors-load-data-csv-show
#| eval: false
#| echo: true
base_url <- "https://ourworldindata.org/grapher/"
url <- paste0(
  base_url,
  "physicians-per-1000-people.csv"
)
doctors <- read_csv(url)
```

```{r}
#| label: doctors-load-data-hide
#| output: false
#| echo: false
#| eval: true
doctors <- read_csv("data/doctors.csv")
```

::: {#tip-doctors-owid .callout-tip}

## R을 통해 Our World in Data에 연결하기

**`owidapi`** R 패키지 [@owidapi]는 Our World in Data 웹사이트에 대한 R 인터페이스를 제공하여 웹사이트를 탐색하지 않고도 R에서 데이터를 검색하고 다운로드할 수 있습니다. 그러나 `read_csv()`에 URL을 전달하는 것보다 훨씬 덜 복잡하지는 않습니다. \index{owidapi!owid\_get}

```{r}
#| label: doctors-load-data-show
#| eval: false
#| echo: true
library(owidapi)
doctors <- owid_get("physicians-per-1000-people")
```

이전에는 **`owidR`** 패키지 [@owidR]도 유사한 인터페이스를 제공했지만, 작성 당시 데이터를 액세스할 때 오류가 발생하는 최신 Our World in Data API를 사용하도록 업데이트되지 않았습니다. \index{owidR!owid}

:::

::: {#tip-doctors-view .callout-tip}

## 나중에 사용할 수 있도록 데이터 저장하기

나중에 사용할 수 있도록 **`readr`**의 `write.csv()` 또는 `write_csv()`를 사용하여 `doctors`의 사본을 CSV 파일로 저장할 수 있습니다. 즉, R을 열 때마다 데이터를 다운로드할 필요가 없으며 분석 중간에 데이터가 업데이트되는 것에 대해 걱정할 필요가 없습니다. 그런 다음 나중에 **`readr`**의 `read.csv` 또는 `read_csv()`로 데이터를 읽을 수 있습니다. \index{readr!read\_csv} \index{readr!write\_csv} \index{utils!read.csv} \index{utils!write.csv}

:::

::: {#tip-doctors-open-data .callout-tip}

## 데이터 소스 찾기

TidyTuesday\index{TidyTuesday} [@tidytuesday]에는 매년 *Bring Your Own Data(나만의 데이터 가져오기)* 주간이 있어 참가자들이 자신의 데이터를 소싱하도록 권장합니다. 일부는 지난 1년 동안 얼마나 많이 달렸는지 시각화하거나 GitHub 기여 그래프를 다시 만드는 등 자신의 데이터를 사용합니다. 다른 사람들은 다른 공개 데이터 소스를 찾아 시각화하는 것을 선택합니다. 그렇다면 공개적으로 사용 가능한 데이터는 어디에서 찾을 수 있을까요?

주제, 기간 및 전 세계 지역을 아우르는 많은 공개 데이터 소스가 있습니다. 일부 정부 기관에는 데이터 포털이 있고, 일부 회사에는 액세스할 수 있는 API가 있으며, 일부 학술 논문에는 데이터가 함께 제공되거나 Google 데이터 세트 검색 엔진({{< monolink "https://datasetsearch.research.google.com/" "datasetsearch.research.google.com" >}})이 관심 있는 데이터를 식별하는 데 도움이 될 수도 있습니다.

:::

## 탐색 작업

데이터를 탐색하여 시각화할 수 있는 흥미로운 패턴이 있는지 확인하는 것으로 시작하겠습니다.

### 데이터 탐색

데이터는 `Entity`(국가 또는 더 큰 지역을 나타냄), `Code`(국가 코드), `Year`(데이터가 관련된 연도) 및 `Physicians (per 1,000 people)`의 `r ncol(doctors)`개 열만 포함하여 합리적으로 작습니다. `r nrow(doctors)`행의 데이터는 `r length(unique(doctors$Entity))`개의 서로 다른 지역(일부는 다른 지역의 집계)을 다루며 데이터는 `r length(unique(doctors$Year))`년을 다룹니다.

```{r}
#| label: doctors-head-data
head(doctors)
```

데이터에 시간 구성 요소가 있을 때 고려해야 할 가장 분명한 패턴 중 하나는 다른 변수가 시간이 지남에 따라 어떻게 변하는지입니다. 시계열 데이터를 시각화하는 데는 선형 차트가 아마도 가장 일반적이지만 간단한 산점도도 데이터에 일반적인 추세가 있는지 나타낼 수 있습니다. 때로는 산점도가 선형 차트보다 깔끔해 보이기도 합니다. 이 차트의 각 지역에 대한 선은 @sec-museums 에서 논의한 것처럼 *스파게티 차트*처럼 보일 것입니다. \index{scatter plot}

```{r, echo=-1}
#| label: fig-doctors-base-plot
#| fig-cap: "기본 R로 만든, 시간이 지남에 따라 인구 1,000명당 의사 수가 증가하는 추세를 보여주는 스타일이 지정되지 않은 간단한 산점도."
#| fig-alt: "기본 R로 만든, 시간이 지남에 따라 인구 1,000명당 의사 수가 증가하는 추세를 보여주는 스타일이 지정되지 않은 간단한 산점도."
par(mar = c(3.1, 4.1, 1.1, 2.1), cex.axis = 0.5, cex.names = 0.5)
plot(
  x = doctors$Year,
  y = doctors$`Physicians (per 1,000 people)`,
  xlab = "Year",
  ylab = "Physicians per 1,000 people"
)
```

1960년과 2020년 사이에 전반적으로 증가하는 추세가 있는 것 같습니다. 우리가 탐색하고 싶어 할 수 있는 이 데이터의 또 다른 중요한 구성 요소는 공간적 측면입니다 - 시간뿐만 아니라 공간에 따른 패턴도 있을까요?

### 탐색적 스케치

공간 데이터를 시각화하는 가장 일반적인 접근 방식은 물론 지도에 표시하는 것입니다. 목표가 다른 국가(또는 기타 정의된 지역)에 따라 변수가 어떻게 변하는지 보여주는 것이라면 변수 값에 따라 국가의 색상을 지정하는 것이 매우 일반적입니다. 이를 종종 *등치 지역도(choropleth maps)*라고 합니다.\index{choropleth map}

![상자 안에 제목이 있고 오른쪽 하단에 범례가 수평으로 배치된 세계 지도의 초기 스케치](images/sketch-doctors.png){#fig-doctors-sketch fig-align="center" fig-alt="상자 안에 제목이 있고 오른쪽 하단에 범례가 수평으로 배치된 세계 지도의 초기 스케치"}

이 시점은 또한 만들 플롯의 방향과 종횡비에 대해 생각하기 시작하기에 좋은 시기입니다. 이는 플롯이 결국 어디에 위치할지에 따라 많이 달라질 것입니다. 예를 들어, 단일 열 학술 기사의 플롯은 일반적으로 가로형 그래프가 될 것입니다. 방향과 종횡비의 선택은 데이터가 얼마나 명확하게 표시되는지에도 영향을 미칠 수 있습니다. 시계열 데이터에 대해 매우 넓은 플롯을 선택하면 계열이 늘어나 추세의 모양이 사라질 수 있습니다. 지도의 경우 만들고 있는 플롯에 이미 기본 종횡비가 있기 때문에 조금 더 제한적입니다. 이 지도의 경우 6x4 종횡비의 가로 방향이 합리적으로 잘 작동할 것입니다. \index{aspect ratio} \index{orientation}

## 플롯 준비하기

@fig-doctors-sketch 에 스케치된 지도를 만들려면 두 가지 작업을 수행해야 합니다. (i) 플롯할 데이터 결정: 어떤 지역, 어떤 연도; (ii) 지역 이름과 국가 코드 이상의 공간 데이터 소싱.

### 데이터 랭글링

이 데이터는 이미 상당히 깔끔하므로 데이터 랭글링을 많이 할 필요는 없습니다. 우리가 정말로 해야 할 유일한 처리는 필요하지 않은 데이터를 제거하고 작업하기 쉽도록 몇 개의 열 이름을 바꾸는 것입니다. **`dplyr`**의 `rename()` 함수를 사용하여 `Entity` 열의 이름을 `region`으로 바꿀 수 있습니다(그 이유는 다음 단락에서 명확해질 것입니다!).\index{dplyr!rename}. 또한 작업하기 쉽도록 `Physicians (per 1,000 people)` 열의 이름을 `doctors`로 바꾸고 일관성을 위해 `Year`를 `year`로 바꿉니다. 데이터에는 각 국가에 대해 여러 항목이 있으며 다른 연도에 걸쳐 있습니다. 시간이 지남에 따라 의사 수가 어떻게 변하는지 보여주는 애니메이션 지도를 만들 *수도* 있지만 지금은 한 시점의 스냅샷을 보여주는 정적 지도로 간단하게 유지하겠습니다. 하지만 약간의 문제가 있습니다. 데이터를 살펴보면 모든 국가에 매년 항목이 있는 것은 아니라는 것을 알 수 있습니다. 각 국가에 대해 가장 최근에 사용 가능한 데이터를 사용해 보겠습니다. 각 `region`에 대해 {dplyr}의 `group_by()`\index{dplyr!group\_by} 및 `slice_max()`\index{dplyr!slice\_max} 조합을 사용하여 가장 최근 연도만 있는 행을 유지합니다.

```{r}
#| label: doctors-wrangle
#| message: false
doctors <- doctors |>
  rename(
    year = Year,
    region = Entity,
    doctors = `Physicians (per 1,000 people)`
  ) |>
  select(region, year, doctors) |>
  group_by(region) |>
  slice_max(year) |>
  ungroup()
```

이 데이터를 세계 지도에 플롯하려면 국가 경계 데이터도 필요합니다. 다행히도 **`ggplot2`**\index{ggplot2!map\_data}에 내장된 `map_data()` 함수가 도움이 될 수 있습니다! 이 함수는 **`maps`** 패키지\index{maps}의 데이터를 가져와 **`ggplot2`**로 직접 플롯할 수 있는 객체로 변환합니다.

```{r}
#| label: map-doctors
#| message: false
world <- map_data("world")
```

물론, 그렇게 간단하지는 않습니다. `world` 지도 데이터를 `doctors` 데이터에 결합해야 하며, 그렇게 하려면 두 데이터 세트에 결합할 열이 필요합니다. 우리는 `region` 열을 사용할 것입니다. `region` 열을 사용하여 이 두 데이터 세트를 결합하려고 하면 예상치 못한 `NA` 값이 생기는 것을 알 수 있습니다. 무슨 일일까요?

::: {#tip-doctors-join .callout-tip}

## 열 이름 바꾸기

결합하기 위해 데이터의 열 이름을 바꿀 필요는 없지만, 데이터 세트 간의 일관성을 유지하기 위해 `Entity`를 `region`으로 바꾼 후 데이터를 작업하는 것이 더 쉬울 수 있습니다.

:::

여기에는 두 가지 문제가 있습니다. 첫째, `doctors` 데이터보다 `world` 데이터에 더 많은 지역이 있습니다:

```{r}
#| label: map-doctors-length
length(unique(world$region))
length(unique(doctors$region))
```

이는 부분적으로 `doctors` 데이터에 암시적으로 누락된 값이 있다는 사실 때문입니다. 지역에 대한 데이터를 사용할 수 없는 경우 해당 지역에 대한 데이터에 행이 존재하지 않습니다. `NA` 값으로 나열되지 않습니다. `doctors`에는 `world`에 존재하지 않는 일부 *지역*도 있습니다. 예를 들어 `"Upper-middle-income countries"` 엔티티는 `doctors` 내에 나열됩니다.

둘째, 지역 이름을 살펴보면 일부 국가의 경우 이름이 다르게 인코딩되어 있음을 알 수 있습니다. 예를 들어 `world` 데이터에서 미국은 `"USA"`로 나열되고 `doctors` 데이터에서는 `"United States"`로 나열됩니다. 여기서 가장 쉬운 방법은 데이터 세트 중 하나에서 다른 값을 수동으로 이름을 바꾸는 것입니다. **`dplyr`**의 `recode()` 함수를 사용하여 이를 수행할 수 있습니다.\index{dplyr!recode} `recode()`는 `old_name = new_name`이라는 다소 특이한(**`tidyverse`**의 경우) 구문을 가지고 있습니다:

```{r}
#| label: map-doctors-wrangle-1
plot_data <- doctors |>
  mutate(
    region =
      recode(region,
        "United Kingdom" = "UK",
        "United States" = "USA",
        "Democratic Republic of Congo" = "Democratic Republic of the Congo",
        "Cote d'Ivoire" = "Ivory Coast",
        "Congo" = "Republic of Congo",
        "Czechia" = "Czech Republic"
      )
  )
```

국가에 해당하지 않는 `doctors`의 `region` 열 항목(예: `"Upper-middle-income countries"`)은 지도에 필요한 값이 아닙니다. 따라서 `left_join()`을 수행할 수 있으며, `world`를 왼쪽에 두고 `world`에 나열된 모든 국가를 유지하고 `doctors`에 해당 값이 있는 국가만 결합합니다. `doctors`에 일치하는 항목이 없는 `world`의 나머지 국가는 `NA` 값으로 나열됩니다. `"Antarctica"`에 대한 행은 필터링됩니다. 남극 대륙은 구를 직사각형으로 투영하는 과정에서 종종 세계 지도(적어도 남극 대륙을 중심으로 하지 않는 지도)에서 불균형한 공간을 차지합니다. \index{dplyr!filter} \index{dplyr!left\_join}

```{r}
#| label: map-doctors-wrangle-2
map_data <- left_join(
  world,
  plot_data,
  by = "region"
) |>
  filter(region != "Antarctica")
```

이제 간단한 지도를 만드는 데 필요한 모든 것이 준비되었습니다.\index{map}

### 첫 번째 플롯

거의 항상 그렇듯이 `ggplot()` 함수로 시작하고 전체 플롯에 적용될 데이터와 미학적 매핑을 전달합니다. 경도(`long`)와 위도(`lat`)는 `x` 및 `y` 축에 전달됩니다. 각 국가의 `fill` 색상은 `doctors` 열을 기반으로 해야 한다고 지정합니다. 또한 `map_id`를 지정합니다. 이는 다른 것들만큼 자주 보이지 않는 미학적 매핑입니다. 이것은 `geom_map()`에 각 지역 폴리곤을 정의하는 열을 알려주는 데 사용됩니다(`group` 미학과는 다릅니다). 그런 다음 `geom_map()`을 사용하여 실제로 지도를 그립니다. \index{ggplot2!ggplot} \index{ggplot2!geom\_map}\index{ggplot2!aes}

::: {#tip-doctors-polygon .callout-tip}

## `geom_map()`의 대안

`geom_sf()`와 `geom_polygon()` 모두 **`ggplot2`** 내에서 지도를 만들기 위한 `geom_map()`의 대안으로 사용할 수 있습니다.

그러나 그들은 다른 형식의 데이터를 기대합니다. `geom_sf()` 함수는 `data.frame` 또는 `tibble`의 열로서의 좌표와 함께 작동하는 `geom_map()`과 달리 `sf` 객체를 기대합니다. `geom_sf()` 사용 예는 @sec-time-zones 를 참조하십시오. \index{ggplot2!geom\_map}\index{ggplot2!geom\_sf}

`geom_map()` 대신 `map_data`를 플롯하기 위해 `geom_polygon()`을 사용할 수도 있지만 원하는 방식으로 지도를 투영하는 것이 더 어렵습니다. \index{ggplot2!geom\_polygon}

:::

```{r}
#| label: fig-doctors-basic-plot-1
#| fig-cap: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도. 지도가 늘어난 것처럼 보입니다."
#| fig-alt: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도. 지도가 늘어난 것처럼 보입니다."
basic_plot <- ggplot(
  data = map_data,
  mapping = aes(
    x = long,
    y = lat,
    map_id = region,
    fill = doctors
  )
) +
  geom_map(map = map_data)
basic_plot
```

이제 데이터를 보여주는 간단한 지도가 생겼지만 몇 가지 문제가 있습니다:

* 지도 투영법이 지정되어 있지 않아 누군가 수직으로 늘린 것처럼 보입니다. 나라는 여전히 알아볼 수 있지만 모양이 딱 맞지는 않습니다.
* 색상 팔레트가 이상적이지 않습니다. 적어도 밝은 색상의 배경에서는 더 밝거나 연한 색상이 더 작은 값을 나타내고 어두운 색상이 더 높은 값을 나타내는 것이 더 직관적입니다[@Schloss]. **`ggplot2`**의 기본 그라데이션 색상 스케일은 반대입니다.
* 없어야 할 레이블(`lat` 및 `long`)이 있고 있어야 할 레이블(예: `title` 및 `subtitle`)이 없습니다.

따라서 초기 플롯의 요소를 수정해 보겠습니다.

## 고급 스타일링

대체 색상 팔레트를 고려한 다음 레이아웃을 마무리하기 전에 어떤 텍스트를 추가해야 할지 생각하는 것으로 시작하겠습니다.

### 색상

존재하는 R 패키지에는 정말 많은 색상 팔레트가 있으며 R 생태계 외부에는 더 많이 있습니다. 사실 **`paletteer`** 패키지 [@paletteer]는 R의 포괄적인 색상 팔레트 컬렉션에 대한 공통 인터페이스를 제공하도록 설계되었습니다. 인기 있는 색상 팔레트 R 패키지는 **`MetBrewer`** [@MetBrewer]입니다. 뉴욕 메트로폴리탄 미술관의 예술 작품에서 영감을 얻은 색상 팔레트 컬렉션입니다. 아름다운 팔레트가 많으며 전통적인 데이터 시각화에서도 잘 작동하는 팔레트가 많습니다. `display_all(colorblind_only = TRUE)`을 사용하여 사용 가능한 모든 팔레트를 볼 수 있습니다. `doctors`는 연속 변수이므로 순차적 팔레트만 살펴보겠습니다. \index{paletteer} \index{MetBrewer} \index{color}

**`MetBrewer`**에는 **`ggplot2`**와 직접 인터페이스하는 함수(예: `scale_fill_met_c()`)가 있지만 팔레트의 일부 색상을 사용하여 강조 및 텍스트 색상에 대한 변수도 정의할 것입니다. 좋은 색상 범위를 얻기 위해 `"Hokusai2"` 팔레트에서 20가지 색상을 추출합니다. `text_col`은 18번째 색상이고 `highlight_col`은 15번째 색상입니다. 배경색을 포함하는 변수 `bg_col`도 정의됩니다.

```{r}
#| label: doctors-colors
library(MetBrewer)
col_palette <- met.brewer("Hokusai2", n = 20)
text_col <- col_palette[18]
highlight_col <- col_palette[15]
bg_col <- "#EADEDA"
```

이 색상들은 **`ggplot2`**\index{ggplot2!scale\_fill\_gradientn}의 `scale_fill_gradientn()`에 전달될 수 있습니다. 색상 스케일의 제한도 설정할 수 있습니다. 범례에 값에 대한 레이블을 추가하는 대신 *더 적은 의사(Fewer doctors)* 및 *더 많은 의사(More doctors)*에 대한 텍스트 레이블을 추가할 수 있습니다. 이들은 색상 스케일의 제한에서 0.8인치 위치에 배치됩니다.

```{r}
#| label: fig-doctors-style-plot-1
#| fig-cap: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도, 다른 색상 체계를 보여줍니다."
#| fig-alt: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도, 다른 색상 체계를 보여줍니다."
col_plot <- basic_plot +
  scale_fill_gradientn(
    colors = col_palette,
    limits = c(0, 10),
    breaks = c(0.8, 9.2),
    labels = c("더 적은 의사", "더 많은 의사")
  )
col_plot
```

### 텍스트와 글꼴

이전 장에서와 마찬가지로 **`sysfonts`**\index{sysfonts} 및 **`showtext`**\index{showtext} 패키지를 사용하여 글꼴을 정의할 수 있습니다. 여기서는 Google Fonts를 통해 *Roboto* 서체를 로드하여 주요 글꼴로 사용하고, 제목에는 *Roboto Slab*을 사용합니다. \index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: doctors-font
font_add_google(name = "Roboto")
font_add_google(name = "Roboto Slab")
font_add_google(name = "Noto Sans KR", family = "noto_sans_kr")
showtext_auto()
showtext_opts(dpi = 300)
body_font <- "Roboto"
title_font <- "Roboto Slab"
korean_font <- "noto_sans_kr"
```

이제 제목, 부제목 및 캡션에 대한 텍스트를 정의할 수 있습니다. 이전 장에서와 마찬가지로 **`ggtext`**를 사용하여 서식을 지정하므로 HTML 구문을 사용하여 줄 바꿈을 추가할 수 있습니다.

```{r}
#| label: doctors-text
title <- "전 세계 의사"
subtitle <- "이 지도는 인구 1,000명당 의사 수를 보여주며, 인구에게 의료 서비스를 제공하는 데 어려움을 겪을 가능성이 더 높은 국가*를 보여줍니다.<br><br>*각 국가에 대해 가장 최근에 사용 가능한 데이터 사용."
```

@sec-cats 에서 설명한 대로 Font Awesome 아이콘을 포함하는 사용자 정의 캡션을 만들어 @sec-turbines 에서 정의한 `source_caption()` 함수에 전달합니다: \index{social\_caption} \index{source\_caption}

```{r}
#| label: doctors-style-3
social <- social_caption(
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
caption <- source_caption(
  source = "Our World in Data",
  sep = "<br>",
  graphic = social
)
```

이러한 텍스트 변수는 `labs()` 함수에 전달될 수 있습니다. \index{ggplot2!labs}

```{r}
#| label: doctors-style-plot-2
text_plot <- col_plot +
  labs(
    title = title,
    subtitle = subtitle,
    caption = caption
  )
```

선택한 서체를 플롯에 적용하려면 `theme` 요소를 조정해야 합니다. \index{ggplot2!theme}

### 테마 조정

**`ggplot2`**의 `theme_void()`를 추가하는 것으로 시작합니다. `theme_void` 함수는 그리드 선, 축 레이블 및 배경을 포함한 모든 `theme` 요소를 제거합니다. 범례와 지정된 제목 및 부제목은 유지됩니다. 이 테마는 축 선, 축 제목 및 그리드 선이 표시되지 않는 것이 더 일반적인 지도에 특히 유용합니다. 다른 기본 제공 테마 옵션과 마찬가지로 `base_size` 및 `base_family`를 설정하여 표시되는 텍스트의 기본 크기와 서체를 설정할 수 있습니다. \index{ggplot2!theme\_void}

또한 `plot.title`, `plot.subtitle` 및 `plot.caption`을 **`ggtext`**의 `element_textbox_simple`을 사용하도록 설정하여 이전 장에서 본 것처럼 마크다운 구문을 허용하고 긴 부제목을 자동으로 줄 바꿈합니다.\index{ggtext!element\_textbox\_simple}

```{r}
#| label: fig-doctors-style-plot-3
#| fig-cap: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도. 지도가 늘어난 것처럼 보이고 제목과 부제목의 글꼴이 서로 가깝습니다."
#| fig-alt: "인구 1,000명당 의사 수에 따라 국가가 색으로 구분된 세계 지도. 지도가 늘어난 것처럼 보이고 제목과 부제목의 글꼴이 서로 가깝습니다."
text_plot +
  theme_void(base_size = 8, base_family = body_font) +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    plot.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    plot.title = element_textbox_simple(
      color = text_col,
      family = title_font
    ),
    plot.subtitle = element_textbox_simple(
      color = text_col
    ),
    plot.caption = element_textbox_simple(
      hjust = 0,
      color = text_col
    )
  )
```

여기서 우리가 만들고 싶어 할 수 있는 미적 디자인 선택 중 하나는 다른 색상의 배경이 있는 배너 안에 제목을 넣는 것입니다. 이것은 꽤 간단한 일처럼 보일 수 있지만 사실 **`ggplot2`**로는 그렇게 쉽지 않습니다. **`cowplot`** [@cowplot]이나 **`grid`** [@rproj]와 같은 패키지를 사용하여 사각형과 텍스트를 그리는 등 문제에 대한 몇 가지 해결책이 있습니다. 그러나 **`ggplot2`** 내에서 이 작업을 수행할 수 있습니다. 즉, 원래 설계되지 않은 방식으로 패싯을 사용하는 것입니다. `map_data`에 `label`이라는 추가 열을 추가하여(데이터의 모든 행에 대해) 제목을 포함시키는 것으로 시작하겠습니다: \index{cowplot} \index{grid}

```{r}
#| label: doctors-facets
map_data$label <- title
```

::: {#tip-doctors-label .callout-tip}

## 열 이름 선택

이 열의 이름은 `label`일 필요는 없으며 기존 열이 아닌 한 원하는 이름을 사용할 수 있습니다.

새 열을 만드는 대신 제목을 `facet_wrap()`에 직접 전달할 수도 있습니다:

```{r}
#| echo: true
#| eval: false
facet_wrap(~"전 세계 의사")
```

:::

그런 다음 `facet_wrap()`을 사용하여 `label` 열 전체에 패싯을 적용할 수 있습니다. 데이터에 `label` 값이 하나만 있으므로 제목만 플롯 상단에 스트립 텍스트로 추가됩니다. 여기에 있는 동안 지도의 국가 윤곽선을 배경과 같은 색으로 만들고 선을 조금 더 두껍게 만들어 보겠습니다. \index{ggplot2!facet\_wrap}

```{r}
#| label: fig-doctors-style-plot-4
#| fig-cap: "패싯 스트립 텍스트에 제목이 복제된 세계 지도, 진한 파란색 배경에 어두운 텍스트."
#| fig-alt: "패싯 스트립 텍스트에 제목이 복제된 세계 지도, 진한 파란색 배경에 어두운 텍스트."
styled_plot <- ggplot(
  data = map_data,
  mapping = aes(
    long,
    lat,
    map_id = region,
    fill = doctors
  )
) +
  geom_map(
    map = map_data,
    color = bg_col,
    linewidth = 0.3
  ) +
  scale_fill_gradientn(
    colors = col_palette,
    limits = c(0, 10),
    breaks = c(0.8, 9.2),
    labels = c("더 적은 의사", "더 많은 의사")
  ) +
  labs(
    title = title,
    subtitle = subtitle,
    caption = caption
  ) +
  facet_wrap(~label) +
  theme_void(base_size = 7, base_family = body_font) +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    plot.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col, color = bg_col
    ),
    plot.title = element_textbox_simple(
      family = korean_font,
      color = text_col,
      family = title_font,
      lineheight = 0.5
    ),
    plot.subtitle = element_textbox_simple(
      family = korean_font,
      color = text_col,
      lineheight = 0.5
    ),
    plot.caption = element_textbox_simple(
      family = korean_font,
      hjust = 0,
      color = text_col,
      lineheight = 0.5
    ),
    strip.background = element_rect(
      fill = highlight_col, color = highlight_col
    )
  )
styled_plot
```

스트립 텍스트에 제목이 포함되어 있으므로 이 플롯에 몇 가지 문제가 있다는 것은 분명합니다:

* `labs()`를 사용하여 설정한 중복 제목이 있으며 `strip.text` 제목은 파란색 배경에 비해 너무 어두워서 읽을 수 없습니다.
* 부제목이 제목 위에 있습니다.
* 지도가 여전히 늘어나 보입니다.
* 범례가 꽤 많은 공간을 차지하고 컬러바의 흰색 눈금이 산만합니다.

처음 두 문제를 해결하기 위해 `labs()`의 `title` 및 `subtitle` 인수를 `NULL`로 설정하여 플롯에서 제거할 수 있습니다. 대신 `labs()`의 `tag` 인수를 사용하여 부제목을 설정할 수 있습니다. `tag`를 사용하는 것의 장점은 `theme()` 내의 `plot.tag.position` 인수를 사용하여 텍스트를 플롯의 어느 곳에나 배치할 수 있다는 것입니다. 테마의 `strip.text` 및 `plot.tag` 인수도 **`ggtext`**의 `element_textbox_simple()`을 사용하여 설정해야 텍스트의 스타일을 원하는 대로 지정할 수 있습니다. 스트립 텍스트 배너가 플롯의 가장자리까지 가도록 `plot.margin`을 사용하여 플롯의 위쪽, 왼쪽, 오른쪽 여백을 `0`으로 설정해야 합니다. \index{ggplot2!theme} \index{ggplot2!labs}

세 번째 문제인 지도가 늘어나 보이는 문제를 해결하기 위해 WGS84(World Geodetic System 1984) CRS(좌표 참조 시스템)를 적용하는 `coord_sf()`를 적용할 수 있습니다. @sec-time-zones 에서는 좌표 참조 시스템에 대해 더 자세히 설명합니다. `y` 축의 상한도 데이터 범위를 넘어 확장하여 `tag`를 사용하여 추가된 부제목을 위한 공간을 만들 수 있습니다. \index{ggplot2!theme} \index{ggplot2!coord\_sf}

```{r}
#| label: doctors-style-plot-4
styled_plot2 <- styled_plot +
  labs(
    title = NULL, subtitle = NULL, tag = subtitle
  ) +
  # tag(부제목) 텍스트를 위한 공간 추가
  coord_sf(ylim = c(-60, 140)) +
  theme(
    # tag(부제목) 텍스트 이동 및 서식 지정
    plot.margin = margin(0, 0, 5, 0),
    plot.tag.position = c(0.015, 0.8),
    plot.tag = element_textbox_simple(
      family = korean_font,
      color = text_col,
      lineheight = 0.6,
      hjust = 0,
      maxwidth = 0.98
    ),
    # 캡션 여백 추가
    plot.caption = element_textbox_simple(
      hjust = 0,
      color = text_col,
      margin = margin(l = 5),
      lineheight = 0.6
    ),
    # 제목 텍스트 색상 변경
    strip.text = element_textbox_simple(
      family = korean_font,
      color = bg_col,
      family = title_font,
      margin = margin(7, 5, 7, 5),
      lineheight = 0.6,
      size = rel(1.7)
    )
  )
```

`plot.tag.position = c(0.015, 0.8)`과 `strip.text` 인수 `margin = margin(7, 5, 7, 5)`에 사용된 값은 *딱 맞게* 만들기 위해 많은 시행착오가 필요했다는 점에 유의하십시오! 이 값을 선택하는 데 마법은 없습니다!

범례 모양의 마지막 문제를 해결하기 위해 `theme`의 스타일 요소를 편집할 수 있습니다. `legend.title`은 `element_blank()`로 빈 요소로 설정하여 제거하고 범례 텍스트 레이블은 `element_text()`로 스타일을 지정합니다. \index{ggplot2!theme} \index{ggplot2!element\_text} \index{ggplot2!element\_blank}

범례의 위치는 `legend.position`, `legend.justification.bottom`, `legend.margin`, `legend.direction` 인수를 통해 설정됩니다.

::: {#tip-doctors-ggplot .callout-tip}

## **`ggplot2`**의 스타일링 가이드

**`ggplot2`** 버전 3.5.0부터는 `guide_*()` 함수 내부에서 개별 범례의 `theme` 스타일을 지정할 수도 있습니다. 버전 3.5.0 이전에는 `legend.position`을 사용하여 플롯 내부에 범례를 배치한 다음 `legend.position.inside` 및 `legend.justification.bottom`이 도입되어 사용자 정의 범례 위치를 더 쉽게 허용했습니다.

다른 점은 `legend.ticks = element_blank()`를 사용하여 컬러바 범례 내부의 흰색 눈금을 제거할 수 있다는 것입니다. **`ggplot2`**의 이전 버전에서는 대신 `guides(fill = guide_colorbar(ticks = FALSE))`가 사용되었습니다. \index{ggplot2!guides} \index{ggplot2!guide\_colorbar}

:::

범례의 크기는 `legend.key.width` 및 `legend.key.height` 인수를 통해 제어됩니다.

```{r}
#| label: fig-doctors-style-plot-5
#| fig-cap: "파란색 배너 안에 제목이 있고 페이지 오른쪽 하단에 수평 컬러바 범례가 있는 세계 지도를 보여주는 최종 스타일 지정된 플롯."
#| fig-alt: "파란색 배너 안에 제목이 있고 페이지 오른쪽 하단에 수평 컬러바 범례가 있는 세계 지도를 보여주는 최종 스타일 지정된 플롯."
styled_plot2 +
  theme(
    # 범례 텍스트
    legend.title = element_blank(),
    legend.text = element_text(
      color = text_col,
      lineheight = 0.5,
      hjust = 0.5
    ),
    # 범례 크기
    legend.key.width = unit(1.5, "cm"),
    legend.key.height = unit(0.3, "cm"),
    # 범례 위치
    legend.position = "bottom",
    legend.justification.bottom = "right",
    legend.margin = margin(-5, 5, 0, 0),
    legend.direction = "horizontal",
    legend.ticks = element_blank()
  )
```

마지막으로 `ggsave()`를 사용하여 사본을 저장할 수 있습니다: \index{ggplot2!ggsave}

```{r}
#| label: doctors-save
#| eval: false
#| echo: true
ggsave(
  filename = "doctors.png",
  width = 5,
  height = 0.67 * 5
)
```

## 회고

@fig-doctors-style-plot-5 의 색상 스케일은 해석하기 꽤 어렵고 값 대신 *더 적은 의사* 및 *더 많은 의사* 레이블을 사용하기로 결정했습니다. 기본 데이터가 단순하고 해석하기 쉬울 때 범례에 값을 표시하면 더 유용한 정보가 추가됩니다. 제목도 아마 더 유익한 것으로 변경될 수 있을 것입니다. \index{color}

데이터가 처리될 때 가장 최근에 사용 가능한 데이터에 대한 값을 보여주는 지도를 플롯하기로 결정했습니다. 이것은 일부 국가의 경우 데이터가 더 최근(따라서 아마도 더 신뢰할 수 있음)인 반면 다른 국가의 경우 훨씬 더 오래되었다는 것을 의미합니다. 실제로 `range(doctors$year)`를 실행하면 플롯의 가장 최근 데이터는 2019년의 것이고 가장 오래된 데이터는 1980년의 것으로 거의 40년의 격차가 있음을 알 수 있습니다! 이로 인해 국가 간을 정확하게 비교하기가 훨씬 어렵고 이 지도에는 각 국가에 대해 데이터가 얼마나 최근인지에 대한 표시가 없습니다. 독자는 국가 간의 차이를 보여주는 결론을 도출할 수 있지만 실제로는 시기 간의 차이입니다. 지도에 불확실성을 표시하는 것은 까다롭고 여기에 간단한 해결책은 없습니다. 아마도 값이 평균보다 위인지 아래인지에 따라 이진 스케일로 색상을 설정하고 색상의 강도로 데이터의 최신성을 나타내는 것이 한 가지 접근 방식일 것입니다. 지도에 불확실성을 시각화하는 기능을 제공하는 **`Vizumap`** 패키지 [@Vizumap]를 사용하여 값과 최신성을 모두 보여주는 이변량 지도를 만들 수 있습니다. 또는 적어도 데이터가 관련된 시간 범위에 대한 더 자세한 설명을 부제목에 포함할 수 있습니다.

::: {.content-visible when-format="html"}

이 시각화의 원본 버전을 개발하는 과정에서 생성된 각 플롯은 **`camcorder`**를 사용하여 캡처되었으며 아래 gif에 표시됩니다. 데이터 시각화 프로세스에서 **`camcorder`**를 사용하는 방법에 대해 자세히 알아보려면 @sec-camcorder 를 참조하십시오.

![](images/doctors.gif){fig-align="center" fig-alt="차트 작성 과정의 Gif"}

:::

## 연습 문제

* `c("France", "Spain", "Italy", "Portugal", "Switzerland")` 지역에 대한 지도만 생성하도록 데이터를 부분 집합으로 만드십시오. x축과 y축의 제한을 변경해야 합니까?

* 이 지역과 국경을 접하는 국가를 지도에 유지하되 중립적인 회색으로 채울 수 있습니까?

